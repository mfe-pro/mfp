/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { TAccordionAppearance, TAccordionSize } from "./components/accordion/mfp-accordion.types";
import { TAlertBorderRadius, TAlertType } from "./components/alert/mfp-alert.types";
import { TAvatarShape, TAvatarSize } from "./components/avatar/mfp-avatar.types";
import { TBadgeSize } from "./components/badge/mfp-badge.types";
import { TButtonAppearance, TButtonBorderRadius, TButtonSize, TButtonType, TButtonVariant } from "./components/button/mfp-button.types";
import { TCardBorderRadius, TCardType } from "./components/card/mfp-card.types";
import { DaysOfWeek, TDatePickerType } from "./components/date-picker/mfp-date-picker.types";
import { Placement } from "./services/interfaces";
import { TInputType, TInputValidation, TInputValue } from "./components/input/mfp-input.types";
import { TDialogBorderRadius, TDialogFooterAppearance, TDialogSize } from "./components/dialog/mfp-dialog.types";
import { TDividerOrientation, TDividerStrokeLinecap, TDividerTitleAlignment } from "./components/divider/mfp-divider.types";
import { TDrawerPlacement, TDrawerPosition } from "./components/drawer/mfp-drawer.types";
import { TEmptyStateSize } from "./components/empty-state/mfp-empty-state.types";
import { TIconWeight } from "./components/icon/mfp-icon.types";
import { TNotificationBorderRadius, TNotificationType } from "./components/notification/mfp-notification.types";
import { TProgressBorderShape, TProgressThickness, TProgressType } from "./components/progress/mfp-progress.types";
import { TRadioGroupOrientation } from "./components/radio-group/mfp-radio-group.types";
import { TSelectValue } from "./components/select/mfp-select";
import { TSideMenuAppearance, TSideMenuSize } from "./components/side-menu/mfp-side-menu.types";
import { TSliderType, TSliderValue } from "./components/slider/mfp-slider.types";
import { TSpinnerSize, TSpinnerTextPosition } from "./components/spinner/mfp-spinner.types";
import { TStatusType } from "./components/status/mfp-status.types";
import { TStepsSize, TStepsType } from "./components/steps/mfp-steps.types";
import { TStepItemStatus } from "./components/step-item/mfp-step-item.types";
import { TSwitchInnerLabel, TSwitchJustifyContent } from "./components/switch/mfp-switch.types";
import { TTabOrientation, TTabPlacement, TTabSize } from "./components/tab/mfp-tab.types";
import { TTagBorderRadius, TTagColor, TTagSize, TTagVariant } from "./components/tag/mfp-tag.types";
import { TTextareaAutoCapitalize, TTextareaWrap } from "./components/textarea/mfp-textarea.types";
import { TToastBorderRadius, TToastPlacement, TToastType } from "./components/toast/mfp-toast.types";
export { TAccordionAppearance, TAccordionSize } from "./components/accordion/mfp-accordion.types";
export { TAlertBorderRadius, TAlertType } from "./components/alert/mfp-alert.types";
export { TAvatarShape, TAvatarSize } from "./components/avatar/mfp-avatar.types";
export { TBadgeSize } from "./components/badge/mfp-badge.types";
export { TButtonAppearance, TButtonBorderRadius, TButtonSize, TButtonType, TButtonVariant } from "./components/button/mfp-button.types";
export { TCardBorderRadius, TCardType } from "./components/card/mfp-card.types";
export { DaysOfWeek, TDatePickerType } from "./components/date-picker/mfp-date-picker.types";
export { Placement } from "./services/interfaces";
export { TInputType, TInputValidation, TInputValue } from "./components/input/mfp-input.types";
export { TDialogBorderRadius, TDialogFooterAppearance, TDialogSize } from "./components/dialog/mfp-dialog.types";
export { TDividerOrientation, TDividerStrokeLinecap, TDividerTitleAlignment } from "./components/divider/mfp-divider.types";
export { TDrawerPlacement, TDrawerPosition } from "./components/drawer/mfp-drawer.types";
export { TEmptyStateSize } from "./components/empty-state/mfp-empty-state.types";
export { TIconWeight } from "./components/icon/mfp-icon.types";
export { TNotificationBorderRadius, TNotificationType } from "./components/notification/mfp-notification.types";
export { TProgressBorderShape, TProgressThickness, TProgressType } from "./components/progress/mfp-progress.types";
export { TRadioGroupOrientation } from "./components/radio-group/mfp-radio-group.types";
export { TSelectValue } from "./components/select/mfp-select";
export { TSideMenuAppearance, TSideMenuSize } from "./components/side-menu/mfp-side-menu.types";
export { TSliderType, TSliderValue } from "./components/slider/mfp-slider.types";
export { TSpinnerSize, TSpinnerTextPosition } from "./components/spinner/mfp-spinner.types";
export { TStatusType } from "./components/status/mfp-status.types";
export { TStepsSize, TStepsType } from "./components/steps/mfp-steps.types";
export { TStepItemStatus } from "./components/step-item/mfp-step-item.types";
export { TSwitchInnerLabel, TSwitchJustifyContent } from "./components/switch/mfp-switch.types";
export { TTabOrientation, TTabPlacement, TTabSize } from "./components/tab/mfp-tab.types";
export { TTagBorderRadius, TTagColor, TTagSize, TTagVariant } from "./components/tag/mfp-tag.types";
export { TTextareaAutoCapitalize, TTextareaWrap } from "./components/textarea/mfp-textarea.types";
export { TToastBorderRadius, TToastPlacement, TToastType } from "./components/toast/mfp-toast.types";
export namespace Components {
    interface MfpAccordion {
        /**
          * The appearance style of accordion
         */
        "appearance": TAccordionAppearance;
        /**
          * If true accordion is disabled
         */
        "disabled": boolean;
        /**
          * If true accordion is expanded
         */
        "expanded": boolean;
        /**
          * Animation is set through JS when the browser does not support CSS calc-size() If true, the accordion animation, will be disabled. No animation will be applied.
         */
        "noAnimation": boolean;
        /**
          * If true accordion expand icon is rotate 180deg when expanded
         */
        "rotate": boolean;
        /**
          * The size of accordion
         */
        "size": TAccordionSize;
    }
    interface MfpAccordionGroup {
        /**
          * The appearance style of accordion to be applied to all accordions
         */
        "appearance": TAccordionAppearance;
        /**
          * If true all accordions are expanded
         */
        "expandAll": boolean;
        /**
          * If true multiple accordions can be expanded at the same time
         */
        "multiple": boolean;
        /**
          * Animation is set through JS when the browser does not support CSS calc-size() If true, the accordion animation, will be disabled. No animation will be applied.
         */
        "noAnimation": boolean;
        /**
          * The size of accordion to be applied to all accordions
         */
        "size": TAccordionSize;
    }
    interface MfpAlert {
        /**
          * If true, the alert will automatically hide after the specified amount of time
         */
        "autoDismiss": boolean;
        /**
          * The corner radius of the alert component
         */
        "border": TAlertBorderRadius;
        /**
          * If true, the close button at the top right of the alert won't be shown
         */
        "disableClose": boolean;
        /**
          * Method to be called to hide the alert component
         */
        "hide": () => Promise<void>;
        /**
          * If true, the alert icon won't be shown
         */
        "hideIcon": boolean;
        /**
          * If true, the alert will be shown
         */
        "open": boolean;
        /**
          * Method to be called to show the alert component
         */
        "show": () => Promise<void>;
        /**
          * If true, the alert component will remain fixed at the top of the page, occupying the full viewport
         */
        "sticky": boolean;
        /**
          * The length of time, in milliseconds, after which the alert will close itself. Only valid if `autoDismiss="true"`
         */
        "time": number;
        /**
          * Type of Alert
         */
        "type": TAlertType;
    }
    interface MfpAvatar {
        /**
          * Alternate text for the avatar image if the image cannot be displayed
         */
        "altText": string;
        /**
          * The image source to load on the avatar (this can be also a base64 encoded image)
         */
        "image": string;
        /**
          * The text to display on avatar
         */
        "initials": string;
        /**
          * A text to use for describing the avatar on assistive devices
         */
        "label": string;
        /**
          * The shape of the avatar
         */
        "shape": TAvatarShape;
        /**
          * The size of the avatar
         */
        "size": TAvatarSize;
    }
    interface MfpBadge {
        /**
          * Badge background color. The value should be a valid value of the palette color
         */
        "backgroundColor"?: string;
        /**
          * The size of the badge. Relevant if badge has no content.
         */
        "size"?: TBadgeSize;
        /**
          * Badge number color. The value should be a valid value of the palette color
         */
        "textColor"?: string;
    }
    interface MfpBreadcrumb {
        /**
          * The `aria-label` attribute to describe the type of navigation
         */
        "ariaLabel": string;
    }
    interface MfpBreadcrumbItem {
        /**
          * The aria-label that corresponds to the full title of the destination page. This won't be shown in the page, but it will be used by screen readers and other assistive devices.
         */
        "ariaLabel": string;
        /**
          * If set, the breadcrumb item will be rendered as an `<a>` with this `href`, otherwise, a `<button>` will be rendered.
         */
        "href": string;
        /**
          * If true, the item is the last element inside breadcrumb
         */
        "isLastItem": boolean;
        /**
          * Where to display the link in the browser context. Relevant only if `href` is set.
         */
        "rel": string;
        /**
          * Where to display the link in the browser context. Relevant only if `href` is set.
         */
        "target": '_blank' | '_parent' | '_self' | '_top';
    }
    /**
     * Buttons are designed for users to take action on a page or a screen.
     */
    interface MfpButton {
        /**
          * The appearance style to apply to the button
         */
        "appearance": TButtonAppearance;
        /**
          * If `true`, it will make the button fit to its parent width.
         */
        "block": boolean;
        /**
          * The corner radius of the button
         */
        "border": TButtonBorderRadius;
        /**
          * If true, the button will be disabled (no interaction allowed)
         */
        "disabled": boolean;
        /**
          * Tells the browser to treat the linked URL as a download. Only used when `href` is set. Details: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attr-download
         */
        "download"?: string;
        /**
          * When set, the underlying button will be rendered as an `<a>` with this `href` instead of a `<button>`
         */
        "href": string;
        /**
          * It determinate how the content should be aligned
         */
        "justifyContent": 'left' | 'center' | 'right';
        /**
          * If `true` it will display the button in a loading state
         */
        "loading": boolean;
        /**
          * The size of the button
         */
        "size": TButtonSize;
        /**
          * Where to display the linked URL, as the name for a browsing context (a `tab`, `window`, or `<iframe>`) Details: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attr-target
         */
        "target": '_blank' | '_parent' | '_self' | '_top';
        /**
          * The default behavior of the button
         */
        "type": TButtonType;
        /**
          * The variant of button to apply on top of the appearance (applicable only to `appearance="primary"`)
         */
        "variant": TButtonVariant;
    }
    interface MfpCard {
        /**
          * The corner radius of the card component
         */
        "border": TCardBorderRadius;
        /**
          * Type of card component
         */
        "type": TCardType;
    }
    interface MfpCheckbox {
        /**
          * If true checkbox displays background on hover
         */
        "backgroundOnHover"?: boolean;
        /**
          * If true checkbox is checked
         */
        "checked"?: boolean;
        /**
          * If true checkbox is disabled
         */
        "disabled"?: boolean;
        /**
          * The form ID that the checkbox is associated with
         */
        "formId"?: string;
        /**
          * The native form validation message
         */
        "formValidationMessage"?: string;
        /**
          * A state that is neither checked nor unchecked
         */
        "indeterminate"?: boolean;
        /**
          * Name of the HTML input form control. Submitted with the form as part of a name/value pair.
         */
        "name": string;
        /**
          * If `true`, it will indicate that the user must specify a value for the checkbox before the owning form can be submitted
         */
        "required"?: boolean;
        /**
          * Remove focus from the native `<input>` HTML element used under the hood. Use this method instead of the global `element.blur()`.
         */
        "vBlur": () => Promise<void>;
        /**
          * Simulate a click event on the native `<input>` HTML element used under the hood. Use this method instead of the global `element.click()`.
         */
        "vClick": () => Promise<void>;
        /**
          * Sets focus on the native `<input>` HTML element used under the hood. Use this method instead of the global `element.focus()`.
         */
        "vFocus": () => Promise<void>;
        /**
          * A string representing the value of the checkbox. Primarily used to differentiate a list of related checkboxes that have the same name.
         */
        "value": string;
    }
    interface MfpDatePicker {
        /**
          * If `true`, the Date picker input will be focused on component render
         */
        "autofocus": boolean;
        /**
          * Clears the selected value.
          * @return 
          * @memberof MfpInput
         */
        "clear": () => Promise<void>;
        /**
          * The clear button aria label
         */
        "clearButtonLabel"?: string;
        /**
          * If `true`, the clear button won't be displayed
         */
        "disableClear"?: boolean;
        /**
          * Indicates whether the Date picker input is disabled or not. If `true`, the Date picker is disabled and cannot be interacted with.
         */
        "disabled"?: boolean;
        /**
          * Represents the distance (gutter or margin) between the Date picker panel and the input element.
         */
        "distance"?: number;
        /**
          * The first day of the week, where Sunday is 0, Monday is 1, etc
         */
        "firstDayOfWeek"?: DaysOfWeek;
        /**
          * The ID of the form that the Date picker input belongs to.
         */
        "form"?: string;
        /**
          * The options to use when formatting the displayed value. Details: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat#using_options
         */
        "formatOptions": Intl.DateTimeFormatOptions;
        /**
          * A function that takes a date and returns true if the date should not be selectable
         */
        "isDateDisallowed"?: (date: Date) => boolean;
        /**
          * The locale for formatting dates. If not set, will use the browser's locale. Details: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#locales_argument
         */
        "locale": Intl.LocalesArgument;
        /**
          * The latest date that can be selected
         */
        "max"?: string;
        /**
          * The earliest date that can be selected
         */
        "min"?: string;
        /**
          * Number of months to show when range is `true`
         */
        "months": number;
        /**
          * Specifies how the next/previous buttons should navigate the calendar. - single: The buttons will navigate by a single month at a time. - months: The buttons will navigate by the number of months displayed per view.
         */
        "monthsPerView": 'single' | 'months';
        /**
          * The Date picker input name.
         */
        "name": string;
        /**
          * If `true`, the Date picker panel will be visible.
         */
        "open"?: boolean;
        /**
          * When set, it will override the height of the Date picker panel.
         */
        "panelHeight"?: string;
        /**
          * The Date picker input placeholder text value
         */
        "placeholder"?: string;
        /**
          * Position of the Date picker panel
         */
        "placement"?: Placement;
        /**
          * Indicates whether or not the Date picker input is required to be filled out before submitting the form.
         */
        "required"?: boolean;
        /**
          * Whether to show days outside the month
         */
        "showOutsideDays": boolean;
        /**
          * Represents the skidding between the Date picker panel and the input element.
         */
        "skidding"?: number;
        /**
          * Defines the strategy to position the Date picker panel
         */
        "strategy"?: 'fixed' | 'absolute';
        /**
          * The date that is tentatively selected e.g. the start of a range selection
         */
        "tentative"?: string;
        /**
          * It defines how the calendar will behave, allowing single date selection, range selection, or multiple date selection
         */
        "type": TDatePickerType;
        /**
          * The validation status of the Select input.
          * @remarks This property is used to indicate the validation status of the select input. It can be set to one of the following values: - `'none'`: No validation status is set. - `'error'`: The input has a validation error. - `'warning'`: The input has a validation warning. - `'success'`: The input has passed validation.
         */
        "validationStatus": TInputValidation;
        /**
          * The select input value represents the currently selected date or range and can be used to reset the field to a previous value. All dates are expected in ISO-8601 format (YYYY-MM-DD).
         */
        "value": string;
    }
    interface MfpDialog {
        /**
          * Corder radius of the dialog component
         */
        "border": TDialogBorderRadius;
        /**
          * Dismiss or cancel the dialog
         */
        "cancel": () => Promise<void>;
        /**
          * If true, the backdrop overlay won't be shown when the dialog opens
         */
        "disableBackdrop": boolean;
        /**
          * If true, the dialog will not close when clicking on the backdrop overlay
         */
        "disableCloseClickOutside": boolean;
        /**
          * If true, the dialog will not close when the [Esc] key is press
         */
        "disableCloseEscKeydown": boolean;
        /**
          * The appearance of footer
         */
        "footerAppearance": TDialogFooterAppearance;
        /**
          * Closes the dialog
         */
        "hide": () => Promise<void>;
        /**
          * If true, it hides the close button
         */
        "hideCloseButton": boolean;
        /**
          * If true, the dialog will be shown as open
         */
        "open": boolean;
        /**
          * Open the dialog
         */
        "show": () => Promise<void>;
        /**
          * The size of the dialog
         */
        "size": TDialogSize;
    }
    interface MfpDivider {
        /**
          * If true, the divider has a dashed pattern
         */
        "dashed": boolean;
        /**
          * The default orientation of the divider
         */
        "orientation": TDividerOrientation;
        /**
          * Set the min width of the divider's stroke when text is not centered. Value expressed in px
         */
        "strokeBasis"?: number;
        /**
          * Set the stroke color of the divider. The value should be a valid value of the palette color
         */
        "strokeColor"?: string;
        /**
          * Set the gap of the divider's stroke. This is applicable when the stroke is dashed
         */
        "strokeDashGap"?: number;
        /**
          * Set the width of each dash of the divider's stroke. This is applicable when the stroke is dashed
         */
        "strokeDashWidth"?: number;
        /**
          * Set the line of the divider's stroke. This is applicable when the stroke is dashed
         */
        "strokeLinecap"?: TDividerStrokeLinecap;
        /**
          * Set the thickness of the divider's stroke. Value expressed in px
         */
        "strokeThickness"?: number;
        /**
          * Set the alignment of the title on the main axis of the divider (horizontal / vertical)
         */
        "titleAlignment"?: TDividerTitleAlignment;
    }
    interface MfpDrawer {
        /**
          * If true, the drawer will not close when clicking outside the panel
         */
        "closeOnClickOutside": boolean;
        /**
          * If true, the dialog will not close when the [Esc] key is pressed
         */
        "closeOnEsc": boolean;
        /**
          * If true, the backdrop overlay will be shown when the drawer opens
         */
        "enableBackdrop": boolean;
        /**
          * Method to be called to hide the drawer component
         */
        "hide": () => Promise<void>;
        /**
          * If true, the drawer component will be shown
         */
        "open": boolean;
        /**
          * @deprecated Defines the position of the drawer
         */
        "placement": TDrawerPlacement;
        /**
          * Defines the position of the drawer
         */
        "position": TDrawerPosition;
        /**
          * Method to be called to show the drawer component
         */
        "show": () => Promise<void>;
    }
    interface MfpDropdown {
        /**
          * If true, the dropdown panel will be visible and won't be shown.
         */
        "disabled"?: boolean;
        /**
          * Represents the distance (gutter or margin) between the panel and the trigger element.
         */
        "distance"?: number;
        /**
          * If true, the panel will remain open after a selection is made.
         */
        "keepOpenOnSelect"?: boolean;
        /**
          * If true, the panel will be visible.
         */
        "open"?: boolean;
        /**
          * When set, it will override the height of the dropdown panel
         */
        "panelHeight"?: string;
        /**
          * Position of the panel
         */
        "placement"?: Placement;
        /**
          * Whether the panel should have the same width as the trigger element
         */
        "sameWidth"?: boolean;
        /**
          * Represents the skidding between the panel and the trigger element.
         */
        "skidding"?: number;
        /**
          * Defines the strategy to position the panel
         */
        "strategy"?: 'fixed' | 'absolute';
    }
    interface MfpEmptyState {
        /**
          * The size of the empty state component
         */
        "size": TEmptyStateSize;
    }
    /**
     * Icons are simplified images that graphically explain the meaning of an object on the screen.
     */
    interface MfpIcon {
        /**
          * Set the stroke color of the SVG. The value should be a valid value of the palette color
         */
        "color"?: string;
        /**
          * Label for the icon, used for accessibility
         */
        "label"?: string;
        /**
          * Icon name to load. Please check all available icons [here](https://phosphoricons.com/)
         */
        "name": string;
        /**
          * Set the size of the SVG
         */
        "size"?: string | number;
        /**
          * Set the source of the SVG. If the source is set, the name property will be ignored
         */
        "src"?: string;
        /**
          * @deprecated It set the icon weight/style
         */
        "weight"?: TIconWeight;
    }
    interface MfpInput {
        /**
          * Controls whether or not the input field should be capitalized and how. Possible values are 'off', 'none', 'on', 'sentences', 'words', and 'characters'. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/autocapitalize
         */
        "autocapitalize": string;
        /**
          * Specifies whether or not the input field should have autocomplete enabled. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete#values
         */
        "autocomplete": string;
        /**
          * Controls whether or not the input field should have autocorrect enabled. Possible values are 'on' and 'off'.
         */
        "autocorrect": 'on' | 'off';
        /**
          * If true, the input will be focused on component render
         */
        "autofocus": boolean;
        /**
          * The clear button aria label
         */
        "clearButtonLabel"?: string;
        /**
          * The amount of time, in milliseconds, to wait before emitting the `mfpInput` event after the input value changes. A value of 0 means no debouncing will occur.
         */
        "debounceTime"?: number;
        /**
          * If true, the clear button won't be displayed
         */
        "disableClear"?: boolean;
        /**
          * Indicates whether the input is disabled or not. If `true`, the input is disabled and cannot be interacted with.
         */
        "disabled"?: boolean;
        /**
          * The ID of the form that the input field belongs to.
         */
        "form"?: string;
        /**
          * The inputmode attribute specifies what kind of input mechanism would be most helpful for users entering content into the input field. This allows a browser to display an appropriate virtual keyboard while editing. Possible values are 'none', 'text', 'decimal', 'numeric', 'tel', 'search', 'email', 'url', and 'date'.
         */
        "inputmode"?: string;
        /**
          * The maximum value that the input field can accept. Only applies to date and number input types.
         */
        "max"?: number | string;
        /**
          * The maximum number of characters that the input field can accept.
         */
        "maxlength": number;
        /**
          * The minimum value that the input field can accept. Only applies to date and number input types.
         */
        "min"?: number | string;
        /**
          * The minimum number of characters that the input field can accept.
         */
        "minlength": number;
        /**
          * The input field name.
         */
        "name": string;
        /**
          * Specifies a regular expression the form control's value should match. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/pattern
         */
        "pattern"?: string;
        /**
          * The input placeholder text value
         */
        "placeholder"?: string;
        /**
          * If true, the input field cannot be modified.
         */
        "readonly"?: boolean;
        /**
          * Indicates whether or not the input field is required to be filled out before submitting the form.
         */
        "required"?: boolean;
        /**
          * A number that specifies the granularity that the value must adhere to. Valid for date, month, week, time, datetime-local, number, and range. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#step
         */
        "step": number | 'any';
        /**
          * The type attribute specifies the type of input field to display. Possible values are 'text', 'password', 'email', 'number', 'tel', 'search', 'url', and more. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#input_types
         */
        "type": TInputType;
        /**
          * The validation status of the input.
          * @remarks This property is used to indicate the validation status of the input. It can be set to one of the following values: - `'none'`: No validation status is set. - `'error'`: The input has a validation error. - `'warning'`: The input has a validation warning. - `'success'`: The input has passed validation.
         */
        "validationStatus": TInputValidation;
        /**
          * The input value, it can be used to reset the input to a previous value
         */
        "value": TInputValue;
    }
    interface MfpNotification {
        /**
          * If true, the notification will automatically hide after the specified amount of time
         */
        "autoDismiss": boolean;
        /**
          * The corder radius of the notification component
         */
        "border": TNotificationBorderRadius;
        /**
          * If true, the close button at the top right of the notification won't be shown
         */
        "disableClose": boolean;
        /**
          * Method to be called to hide the notification component
         */
        "hide": () => Promise<void>;
        /**
          * If true, the notification icon won't be shown
         */
        "hideIcon": boolean;
        /**
          * If true, the notification will be shown
         */
        "open": boolean;
        /**
          * Method to be called to show the notification component
         */
        "show": () => Promise<void>;
        /**
          * The length of time, in milliseconds, after which the notification will close itself. Only valid if `autoDismiss="true"`
         */
        "time": number;
        /**
          * This method can be used to display notifications in a fixed-position element that allows for stacking multiple notifications vertically
         */
        "toast": () => Promise<void>;
        /**
          * Type of Notification
         */
        "type": TNotificationType;
    }
    interface MfpOption {
        /**
          * If true, the option is disabled.
         */
        "disabled"?: boolean;
        /**
          * If true, the option is hidden.
         */
        "hidden": boolean;
        /**
          * If true, the option is selected and active.
         */
        "selected": boolean;
        /**
          * A string representing the value of the option. Can be used to identify the item
         */
        "value"?: string;
    }
    interface MfpOptionGroup {
    }
    interface MfpOptionList {
        /**
          * Aria label for the list.
         */
        "ariaLabel": string;
    }
    interface MfpPageTitle {
    }
    interface MfpPanel {
        /**
          * Represents the distance (gutter or margin) between the panel and the trigger element.
         */
        "distance"?: number;
        /**
          * If true, the panel will be visible.
         */
        "open"?: boolean;
        /**
          * Position of the panel
         */
        "placement"?: Placement;
        /**
          * Whether the panel should have the same width as the trigger element
         */
        "sameWidth"?: boolean;
        /**
          * Represents the skidding between the panel and the trigger element.
         */
        "skidding"?: number;
        /**
          * Defines the strategy to position the panel
         */
        "strategy"?: 'fixed' | 'absolute';
    }
    interface MfpProgress {
        /**
          * It will set the border style of the progress bar
         */
        "borderShape": TProgressBorderShape;
        /**
          * If `true`, a tooltip will be shown displaying the progress value
         */
        "enableTooltip": boolean;
        /**
          * If `true` the indeterminate state of progress bar is enabled
         */
        "indeterminate": boolean;
        /**
          * If `true`, a label text showing the value (in percentage) will be shown
         */
        "label": boolean;
        /**
          * Progress bar thickness
         */
        "thickness": TProgressThickness;
        /**
          * Progress type
         */
        "type": TProgressType;
        /**
          * A number representing the current value of the progress bar
         */
        "value": number;
    }
    interface MfpRadio {
        /**
          * If true radio displays background on hover
         */
        "backgroundOnHover"?: boolean;
        /**
          * If true radio input is checked
         */
        "checked"?: boolean;
        /**
          * If true radio input is disabled
         */
        "disabled"?: boolean;
        /**
          * The form ID that the radio input is associated with
         */
        "formId"?: string;
        /**
          * Name of the HTML input form control. Submitted with the form as part of a name/value pair.
         */
        "name": string;
        /**
          * If `true`, it will indicate that the user must specify a value for the radio before the owning form can be submitted
         */
        "required"?: boolean;
        /**
          * Remove focus from the native `<input>` HTML element used under the hood. Use this method instead of the global `element.blur()`.
         */
        "vBlur": () => Promise<void>;
        /**
          * Simulate a click event on the native `<input>` HTML element used under the hood. Use this method instead of the global `element.click()`.
         */
        "vClick": () => Promise<void>;
        /**
          * Sets focus on the native `<input>` HTML element used under the hood. Use this method instead of the global `element.focus()`.
         */
        "vFocus": () => Promise<void>;
        /**
          * A string representing the value of the radio.
         */
        "value": string;
    }
    interface MfpRadioGroup {
        /**
          * If true, all radio inputs in the group will display a background on hover
         */
        "backgroundOnHover"?: boolean;
        /**
          * A number representing the delay time (in milliseconds) that `mfpChange` event handler gets triggered once the value change
         */
        "debounceTime": number;
        /**
          * If true radio inputs are disabled
         */
        "disabled"?: boolean;
        /**
          * If true displays fieldset
         */
        "fieldset"?: boolean;
        /**
          * Name of the HTML input form control. Submitted with the form as part of a name/value pair.
         */
        "name": string;
        /**
          * The display orientation of the radio inputs
         */
        "orientation": TRadioGroupOrientation;
        /**
          * A string representing the value of the radio.
         */
        "value"?: string;
    }
    interface MfpSelect {
        /**
          * If true, the Select input will be focused on component render
         */
        "autofocus": boolean;
        /**
          * Clears the selected value.
          * @return 
          * @memberof MfpSelect
         */
        "clear": () => Promise<void>;
        /**
          * The clear button aria label
         */
        "clearButtonLabel"?: string;
        /**
          * The amount of time, in milliseconds, to wait before emitting the `mfpInput` event after the input value changes. A value of 0 means no debouncing will occur.
         */
        "debounceTime"?: number;
        /**
          * If true, the clear button won't be displayed
         */
        "disableClear"?: boolean;
        /**
          * Indicates whether the Select input is disabled or not. If `true`, the Select is disabled and cannot be interacted with.
         */
        "disabled"?: boolean;
        /**
          * Represents the distance (gutter or margin) between the Select panel and the input element.
         */
        "distance"?: number;
        /**
          * The ID of the form that the Select input belongs to.
         */
        "form"?: string;
        /**
          * If true, the Select panel will remain open after a selection is made.
         */
        "keepOpenOnSelect"?: boolean;
        /**
          * The maximum number of tags to display when multiple selection is enabled
         */
        "maxTagsVisible": number;
        /**
          * If true, the Select input will allow multiple selections.
         */
        "multiple"?: boolean;
        /**
          * The Select input name.
         */
        "name": string;
        /**
          * If true, the Select panel will be visible.
         */
        "open"?: boolean;
        /**
          * When set, it will override the height of the Select panel.
         */
        "panelHeight"?: string;
        /**
          * The Select input placeholder text value
         */
        "placeholder"?: string;
        /**
          * Position of the Select panel
         */
        "placement"?: Placement;
        /**
          * If true, the list of options cannot be filtered (searching won't be available)
         */
        "readonly"?: boolean;
        /**
          * Indicates whether or not the Select input is required to be filled out before submitting the form.
         */
        "required"?: boolean;
        /**
          * Whether the panel should have the Select same width as the input element
         */
        "sameWidth"?: boolean;
        /**
          * Represents the skidding between the Select panel and the input element.
         */
        "skidding"?: number;
        /**
          * Defines the strategy to position the Select panel
         */
        "strategy"?: 'fixed' | 'absolute';
        /**
          * The validation status of the Select input.
          * @remarks This property is used to indicate the validation status of the select input. It can be set to one of the following values: - `'none'`: No validation status is set. - `'error'`: The input has a validation error. - `'warning'`: The input has a validation warning. - `'success'`: The input has passed validation.
         */
        "validationStatus": TInputValidation;
        /**
          * The select input value, it can be used to reset the field to a previous value
         */
        "value": TSelectValue;
    }
    interface MfpSideMenu {
        /**
          * It sets a predefined appearance of the side menu
         */
        "appearance": TSideMenuAppearance;
        /**
          * If true, the container will reduce its width
         */
        "collapse": boolean;
        /**
          * It sets the size of the navigation menu items
         */
        "size": TSideMenuSize;
        /**
          * Toggle the collapse state of the side menu
         */
        "toggleCollapse": () => Promise<void>;
    }
    interface MfpSideMenuItem {
        /**
          * If true, the menu item will be shown as active/selected.
         */
        "active": boolean;
        /**
          * If true, the item label and suffix will be hidden and the with will be reduce according to its parent
         */
        "collapse": boolean;
        /**
          * If true, the menu item will be disabled (no interaction allowed)
         */
        "disabled": boolean;
    }
    interface MfpSlider {
        /**
          * The amount of time, in milliseconds, to wait to trigger the `mfpChange` event after each value change.
         */
        "debounceTime": number;
        /**
          * If `true` the slider is disabled.
         */
        "disabled"?: boolean;
        /**
          * If `true`, a tooltip will be shown displaying the progress value
         */
        "enableTooltip": boolean;
        /**
          * If `true` it will show the value label on a side of the slider track area
         */
        "enableValueIndicator"?: boolean;
        /**
          * A number representing the amount to remain between the minimum and maximum values (only for range type).
         */
        "gap": number;
        /**
          * A number representing the max value of the slider.
         */
        "max": number;
        /**
          * A number representing the min value of the slider.
         */
        "min": number;
        /**
          * A number representing the step of the slider. ⚠️ Please notice that the value (or list of values if the slider type is `range`) will be rounded to the nearest multiple of `step`.
         */
        "step": number;
        /**
          * If `true`, a tooltip will always display the progress value. It relies on enableTooltip and if enableTooltip is false, tooltipAlwaysVisible cannot be true.
         */
        "tooltipAlwaysVisible": boolean;
        /**
          * It defines the type of slider to display
         */
        "type": TSliderType;
        /**
          * The value of the slider. - If the slider type is `single`, the value is a number. - If the slider type is `range`, the value is an array of two numbers (the first number represents the `min` value and the second number represents the `max` value).
         */
        "value": TSliderValue;
    }
    /**
     * Spinners are designed for users to display data loading.
     */
    interface MfpSpinner {
        /**
          * If `false`, the animation on the icon element will be stopped
         */
        "animation"?: boolean;
        /**
          * It defines the size of the icon element displayed
         */
        "size": TSpinnerSize;
        /**
          * It defines the position of the label text
         */
        "textPosition": TSpinnerTextPosition;
    }
    interface MfpStatus {
        /**
          * It defines the type of status to display
         */
        "type": TStatusType;
    }
    interface MfpStepItem {
        /**
          * It defines prefix size
         */
        "size"?: TStepsSize;
        /**
          * It defines step item appearance based on its status
         */
        "status"?: TStepItemStatus;
        /**
          * It defines the step item type used
         */
        "type"?: TStepsType;
    }
    interface MfpSteps {
        /**
          * The color of the line that connects the steps. It should be a valid declarative color token.
         */
        "dividerColor": string;
        /**
          * The size of the steps
         */
        "size": TStepsSize;
        /**
          * The type of prefix element to use on the step items
         */
        "type": TStepsType;
    }
    /**
     * Toggle switches are digital on/off switches.
     * They should provide immediate results, giving users the freedom to control their preferences as needed.
     */
    interface MfpSwitch {
        /**
          * If true, a background will be displayed on hover
         */
        "backgroundOnHover"?: boolean;
        /**
          * It indicates whether if the switch is `ON` by default (when the page loads)
         */
        "checked"?: boolean;
        /**
          * If true, the switch control will be disabled and no interaction will be allowed
         */
        "disabled"?: boolean;
        /**
          * If true, the component will take the full width space available on the parent container
         */
        "fullWidth"?: boolean;
        /**
          * It indicates how to to display the on/off marks inside the control, with icons or none (default)
         */
        "innerLabel"?: TSwitchInnerLabel;
        /**
          * It defines how to distribute the space between and around the control and the label text (https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content)
         */
        "justifyContent"?: TSwitchJustifyContent;
        /**
          * Name of the form control. Submitted with the form as part of a name/value pair
         */
        "name": string;
        /**
          * If `true`, it will indicate that the user must switch `ON` the element before the owning form can be submitted
         */
        "required"?: boolean;
        /**
          * If true, the order of the control and the label text will be changed
         */
        "reverseOrder"?: boolean;
        /**
          * Remove focus from the native `<input>` HTML element used under the hood. Use this method instead of the global `element.blur()`.
         */
        "vBlur": () => Promise<void>;
        /**
          * Simulate a click event on the native `<input>` HTML element used under the hood. Use this method instead of the global `element.click()`.
         */
        "vClick": () => Promise<void>;
        /**
          * Sets focus on the native `<input>` HTML element used under the hood. Use this method instead of the global `element.focus()`.
         */
        "vFocus": () => Promise<void>;
        /**
          * The input control's value, submitted as a name/value pair with form data.
         */
        "value"?: string;
    }
    interface MfpTab {
        /**
          * If true tab is active
         */
        "active"?: boolean;
        /**
          * The tab panel id that the tab controls
         */
        "controls": string;
        /**
          * If true tab is disabled
         */
        "disabled": boolean;
        /**
          * Sets tabindex on the native `<button>` HTML element used under the hood. This method is used inside `<mfp-tab-group>` to make tab focusable after the active one is focused
         */
        "enableFocus": (value: boolean) => Promise<void>;
        /**
          * The direction that tab should be render
         */
        "orientation"?: TTabOrientation;
        /**
          * The placement that tab should be render
         */
        "placement"?: TTabPlacement;
        /**
          * The size of the tab
         */
        "size": TTabSize;
        /**
          * The id of the tab
         */
        "tabId": string;
        /**
          * Remove focus from the native `<button>` HTML element used under the hood. Use this method instead of the global `element.blur()`.
         */
        "vBlur": () => Promise<void>;
        /**
          * Simulate a click event on the native `<button>` HTML element used under the hood. Use this method instead of the global `element.click()`.
         */
        "vClick": () => Promise<void>;
        /**
          * Sets focus on the native `<button>` HTML element used under the hood. Use this method instead of the global `element.focus()`.
         */
        "vFocus": () => Promise<void>;
    }
    interface MfpTabGroup {
        /**
          * A number representing the delay value applied to mfpChange event handler
         */
        "debounceTime": number;
        /**
          * If true, the underline divider below the tabs won't be shown
         */
        "disableDivider": boolean;
        /**
          * The direction that tab should be render
         */
        "orientation"?: TTabOrientation;
        /**
          * The placement that tab should be render
         */
        "placement"?: TTabPlacement;
        /**
          * The size of the tab
         */
        "size": TTabSize;
        /**
          * A string representing the id of the selected tab.
         */
        "value": string;
    }
    interface MfpTag {
        /**
          * The corner radius of the Tag (will override size's predefined border)
         */
        "border": TTagBorderRadius;
        /**
          * If true, the Tag can be clickable
         */
        "clickable": boolean;
        /**
          * The color style of the Tag
         */
        "color": TTagColor;
        /**
          * If true, the Tag will be disabled (only if clickable = `true`, no interaction allowed)
         */
        "disabled"?: boolean;
        /**
          * If true, the Tag component will hidden (only if removable = `true`)
         */
        "hidden": boolean;
        /**
          * Method to be called to remove the tag component
         */
        "hide": () => Promise<void>;
        /**
          * If true, the Tag component can be removed
         */
        "removable": boolean;
        /**
          * If true, the Tag is selected (only if clickable = `true`)
         */
        "selected": boolean;
        /**
          * Method to be called to show the tag component
         */
        "show": () => Promise<void>;
        /**
          * The size of the Tag component
         */
        "size": TTagSize;
        /**
          * The variant of Tag to apply on top of the variant
         */
        "variant": TTagVariant;
    }
    interface MfpTextarea {
        /**
          * If `true`, the textarea will automatically grow and shrink to fit its contents. If `false`, the textarea will have a fixed height specified by the `rows` property.
         */
        "autoGrow": boolean;
        /**
          * Controls whether or not the textarea field should be capitalized and how. Possible values are 'off', 'none', 'on', 'sentences', 'words', and 'characters'. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/autocapitalize
         */
        "autocapitalize": TTextareaAutoCapitalize;
        /**
          * Specifies whether or not the textarea field should have autocomplete enabled. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete#values
         */
        "autocomplete": string;
        /**
          * Controls whether or not the textarea field should have autocorrect enabled. Possible values are 'on' and 'off'.
         */
        "autocorrect": 'on' | 'off';
        /**
          * If true, the textarea will be focused on component render
         */
        "autofocus": boolean;
        /**
          * The amount of time, in milliseconds, to wait before emitting the `mfpInput` event after the textarea value changes. A value of 0 means no debouncing will occur.
         */
        "debounceTime"?: number;
        /**
          * If `true`, it will block the user's ability to resize the textarea.
         */
        "disableResize"?: boolean;
        /**
          * If `true`, the user cannot interact with the textarea.
         */
        "disabled": boolean;
        /**
          * The ID of the form that the textarea field belongs to.
         */
        "form"?: string;
        /**
          * The maximum number of characters that can be entered into the textarea (`0`: no limit). When enabled, a character counter will be shown underneath the textarea.
         */
        "maxlength": number;
        /**
          * The name of the textarea element.
         */
        "name": string;
        /**
          * The placeholder text to show when there is no value.
         */
        "placeholder": string;
        /**
          * If true, the textarea field cannot be modified.
         */
        "readonly"?: boolean;
        /**
          * Indicates whether or not the textarea field is required to be filled out before submitting the form.
         */
        "required"?: boolean;
        /**
          * The number of visible text lines for the control. It must be a positive integer.
         */
        "rows": number;
        /**
          * If true, the textarea content may be checked for spelling errors.
         */
        "spellcheck": boolean;
        /**
          * The validation status of the textarea.
          * @remarks This property is used to indicate the validation status of the textarea. It can be set to one of the following values: - `'none'`: No validation status is set. - `'error'`: The textarea has a validation error. - `'warning'`: The textarea has a validation warning. - `'success'`: The textarea has passed validation.
         */
        "validationStatus": TInputValidation;
        /**
          * The value of the textarea. It can be used to reset the textarea to a previous value.
         */
        "value": string;
        /**
          * Specifies how the text in a text area is to be wrapped when submitted in a form
         */
        "wrap": TTextareaWrap;
    }
    interface MfpToast {
        /**
          * The corder radius of the toast component
         */
        "border": TToastBorderRadius;
        /**
          * Method to be called to hide the toast component
         */
        "hide": () => Promise<void>;
        /**
          * If true will hide toast icon
         */
        "hideIcon": boolean;
        /**
          * If true, the toast will be shown
         */
        "open": boolean;
        /**
          * Placement of toast
         */
        "placement": TToastPlacement;
        /**
          * Method to be called to show the toast component
         */
        "show": () => Promise<void>;
        /**
          * The length of time, in milliseconds, after which the toast will close itself
         */
        "time": number;
        /**
          * This method can be used to display toasts in a fixed-position element that allows for stacking multiple toasts vertically
         */
        "toast": () => Promise<void>;
        /**
          * Type of toast
         */
        "type": TToastType;
    }
    interface MfpTooltip {
        /**
          * If true, the tooltip will always be visible
         */
        "alwaysVisible"?: boolean;
        /**
          * Set the action when the tooltip should be displayed, on hover (default) or click
         */
        "displayOn": 'click' | 'hover';
        /**
          * Distance between trigger element and tooltip
         */
        "distance"?: number;
        /**
          * Hides the tooltip
         */
        "hide": () => Promise<void>;
        /**
          * If true, the arrow on the tooltip content won't be shown
         */
        "hideArrow"?: boolean;
        "placement"?: Placement;
        /**
          * Whether the tooltip should have the same width as the trigger element (applicable only for content shorter than the trigger element)
         */
        "sameWidth"?: boolean;
        /**
          * Shows the tooltip
         */
        "show": () => Promise<void>;
        /**
          * Indicates whether or not the tooltip is visible when the component is first rendered, and when interacting with the trigger
         */
        "visible"?: boolean;
    }
}
export interface MfpAccordionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpAccordionElement;
}
export interface MfpAlertCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpAlertElement;
}
export interface MfpBreadcrumbCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpBreadcrumbElement;
}
export interface MfpBreadcrumbItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpBreadcrumbItemElement;
}
export interface MfpButtonCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpButtonElement;
}
export interface MfpCheckboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpCheckboxElement;
}
export interface MfpDatePickerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpDatePickerElement;
}
export interface MfpDialogCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpDialogElement;
}
export interface MfpDrawerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpDrawerElement;
}
export interface MfpDropdownCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpDropdownElement;
}
export interface MfpIconCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpIconElement;
}
export interface MfpInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpInputElement;
}
export interface MfpNotificationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpNotificationElement;
}
export interface MfpOptionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpOptionElement;
}
export interface MfpOptionListCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpOptionListElement;
}
export interface MfpRadioCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpRadioElement;
}
export interface MfpRadioGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpRadioGroupElement;
}
export interface MfpSelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpSelectElement;
}
export interface MfpSideMenuCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpSideMenuElement;
}
export interface MfpSideMenuItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpSideMenuItemElement;
}
export interface MfpSliderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpSliderElement;
}
export interface MfpStepItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpStepItemElement;
}
export interface MfpSwitchCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpSwitchElement;
}
export interface MfpTabCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpTabElement;
}
export interface MfpTabGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpTabGroupElement;
}
export interface MfpTagCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpTagElement;
}
export interface MfpTextareaCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpTextareaElement;
}
export interface MfpToastCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMfpToastElement;
}
declare global {
    interface HTMLMfpAccordionElementEventMap {
        "mfpBlur": HTMLMfpAccordionElement;
        "mfpFocus": HTMLMfpAccordionElement;
        "mfpOpen": HTMLMfpAccordionElement;
        "mfpAfterOpen": HTMLMfpAccordionElement;
        "mfpClose": HTMLMfpAccordionElement;
        "mfpAfterClose": HTMLMfpAccordionElement;
        "mfpClick": HTMLMfpAccordionElement;
    }
    interface HTMLMfpAccordionElement extends Components.MfpAccordion, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpAccordionElementEventMap>(type: K, listener: (this: HTMLMfpAccordionElement, ev: MfpAccordionCustomEvent<HTMLMfpAccordionElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpAccordionElementEventMap>(type: K, listener: (this: HTMLMfpAccordionElement, ev: MfpAccordionCustomEvent<HTMLMfpAccordionElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpAccordionElement: {
        prototype: HTMLMfpAccordionElement;
        new (): HTMLMfpAccordionElement;
    };
    interface HTMLMfpAccordionGroupElement extends Components.MfpAccordionGroup, HTMLStencilElement {
    }
    var HTMLMfpAccordionGroupElement: {
        prototype: HTMLMfpAccordionGroupElement;
        new (): HTMLMfpAccordionGroupElement;
    };
    interface HTMLMfpAlertElementEventMap {
        "mfpHide": any;
        "mfpShow": any;
        "mfpAfterShow": any;
        "mfpAfterHide": any;
    }
    interface HTMLMfpAlertElement extends Components.MfpAlert, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpAlertElementEventMap>(type: K, listener: (this: HTMLMfpAlertElement, ev: MfpAlertCustomEvent<HTMLMfpAlertElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpAlertElementEventMap>(type: K, listener: (this: HTMLMfpAlertElement, ev: MfpAlertCustomEvent<HTMLMfpAlertElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpAlertElement: {
        prototype: HTMLMfpAlertElement;
        new (): HTMLMfpAlertElement;
    };
    interface HTMLMfpAvatarElement extends Components.MfpAvatar, HTMLStencilElement {
    }
    var HTMLMfpAvatarElement: {
        prototype: HTMLMfpAvatarElement;
        new (): HTMLMfpAvatarElement;
    };
    interface HTMLMfpBadgeElement extends Components.MfpBadge, HTMLStencilElement {
    }
    var HTMLMfpBadgeElement: {
        prototype: HTMLMfpBadgeElement;
        new (): HTMLMfpBadgeElement;
    };
    interface HTMLMfpBreadcrumbElementEventMap {
        "mfpBreadcrumbBlur": HTMLMfpBreadcrumbItemElement;
        "mfpBreadcrumbFocus": HTMLMfpBreadcrumbItemElement;
        "mfpBreadcrumbClick": HTMLMfpBreadcrumbItemElement;
    }
    interface HTMLMfpBreadcrumbElement extends Components.MfpBreadcrumb, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpBreadcrumbElementEventMap>(type: K, listener: (this: HTMLMfpBreadcrumbElement, ev: MfpBreadcrumbCustomEvent<HTMLMfpBreadcrumbElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpBreadcrumbElementEventMap>(type: K, listener: (this: HTMLMfpBreadcrumbElement, ev: MfpBreadcrumbCustomEvent<HTMLMfpBreadcrumbElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpBreadcrumbElement: {
        prototype: HTMLMfpBreadcrumbElement;
        new (): HTMLMfpBreadcrumbElement;
    };
    interface HTMLMfpBreadcrumbItemElementEventMap {
        "mfpBlur": HTMLMfpBreadcrumbItemElement;
        "mfpFocus": HTMLMfpBreadcrumbItemElement;
        "mfpClick": HTMLMfpBreadcrumbItemElement;
    }
    interface HTMLMfpBreadcrumbItemElement extends Components.MfpBreadcrumbItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpBreadcrumbItemElementEventMap>(type: K, listener: (this: HTMLMfpBreadcrumbItemElement, ev: MfpBreadcrumbItemCustomEvent<HTMLMfpBreadcrumbItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpBreadcrumbItemElementEventMap>(type: K, listener: (this: HTMLMfpBreadcrumbItemElement, ev: MfpBreadcrumbItemCustomEvent<HTMLMfpBreadcrumbItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpBreadcrumbItemElement: {
        prototype: HTMLMfpBreadcrumbItemElement;
        new (): HTMLMfpBreadcrumbItemElement;
    };
    interface HTMLMfpButtonElementEventMap {
        "mfpBlur": HTMLMfpButtonElement;
        "mfpFocus": HTMLMfpButtonElement;
        "mfpClick": HTMLMfpButtonElement;
    }
    /**
     * Buttons are designed for users to take action on a page or a screen.
     */
    interface HTMLMfpButtonElement extends Components.MfpButton, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpButtonElementEventMap>(type: K, listener: (this: HTMLMfpButtonElement, ev: MfpButtonCustomEvent<HTMLMfpButtonElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpButtonElementEventMap>(type: K, listener: (this: HTMLMfpButtonElement, ev: MfpButtonCustomEvent<HTMLMfpButtonElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpButtonElement: {
        prototype: HTMLMfpButtonElement;
        new (): HTMLMfpButtonElement;
    };
    interface HTMLMfpCardElement extends Components.MfpCard, HTMLStencilElement {
    }
    var HTMLMfpCardElement: {
        prototype: HTMLMfpCardElement;
        new (): HTMLMfpCardElement;
    };
    interface HTMLMfpCheckboxElementEventMap {
        "mfpChange": { checked: boolean };
        "mfpFocus": HTMLMfpCheckboxElement;
        "mfpBlur": HTMLMfpCheckboxElement;
    }
    interface HTMLMfpCheckboxElement extends Components.MfpCheckbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpCheckboxElementEventMap>(type: K, listener: (this: HTMLMfpCheckboxElement, ev: MfpCheckboxCustomEvent<HTMLMfpCheckboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpCheckboxElementEventMap>(type: K, listener: (this: HTMLMfpCheckboxElement, ev: MfpCheckboxCustomEvent<HTMLMfpCheckboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpCheckboxElement: {
        prototype: HTMLMfpCheckboxElement;
        new (): HTMLMfpCheckboxElement;
    };
    interface HTMLMfpDatePickerElementEventMap {
        "mfpBlur": HTMLMfpDatePickerElement;
        "mfpChange": { value: string; el: HTMLMfpDatePickerElement };
        "mfpClear": HTMLMfpDatePickerElement;
        "mfpFocus": HTMLMfpDatePickerElement;
    }
    interface HTMLMfpDatePickerElement extends Components.MfpDatePicker, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpDatePickerElementEventMap>(type: K, listener: (this: HTMLMfpDatePickerElement, ev: MfpDatePickerCustomEvent<HTMLMfpDatePickerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpDatePickerElementEventMap>(type: K, listener: (this: HTMLMfpDatePickerElement, ev: MfpDatePickerCustomEvent<HTMLMfpDatePickerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpDatePickerElement: {
        prototype: HTMLMfpDatePickerElement;
        new (): HTMLMfpDatePickerElement;
    };
    interface HTMLMfpDialogElementEventMap {
        "mfpCancel": void;
        "mfpClose": void;
        "mfpOpen": void;
        "mfpAfterOpen": void;
        "mfpAfterClose": void;
    }
    interface HTMLMfpDialogElement extends Components.MfpDialog, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpDialogElementEventMap>(type: K, listener: (this: HTMLMfpDialogElement, ev: MfpDialogCustomEvent<HTMLMfpDialogElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpDialogElementEventMap>(type: K, listener: (this: HTMLMfpDialogElement, ev: MfpDialogCustomEvent<HTMLMfpDialogElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpDialogElement: {
        prototype: HTMLMfpDialogElement;
        new (): HTMLMfpDialogElement;
    };
    interface HTMLMfpDividerElement extends Components.MfpDivider, HTMLStencilElement {
    }
    var HTMLMfpDividerElement: {
        prototype: HTMLMfpDividerElement;
        new (): HTMLMfpDividerElement;
    };
    interface HTMLMfpDrawerElementEventMap {
        "mfpClose": any;
        "mfpOpen": any;
        "mfpAfterOpen": any;
        "mfpAfterClose": any;
    }
    interface HTMLMfpDrawerElement extends Components.MfpDrawer, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpDrawerElementEventMap>(type: K, listener: (this: HTMLMfpDrawerElement, ev: MfpDrawerCustomEvent<HTMLMfpDrawerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpDrawerElementEventMap>(type: K, listener: (this: HTMLMfpDrawerElement, ev: MfpDrawerCustomEvent<HTMLMfpDrawerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpDrawerElement: {
        prototype: HTMLMfpDrawerElement;
        new (): HTMLMfpDrawerElement;
    };
    interface HTMLMfpDropdownElementEventMap {
        "mfpOpen": { open: boolean };
    }
    interface HTMLMfpDropdownElement extends Components.MfpDropdown, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpDropdownElementEventMap>(type: K, listener: (this: HTMLMfpDropdownElement, ev: MfpDropdownCustomEvent<HTMLMfpDropdownElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpDropdownElementEventMap>(type: K, listener: (this: HTMLMfpDropdownElement, ev: MfpDropdownCustomEvent<HTMLMfpDropdownElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpDropdownElement: {
        prototype: HTMLMfpDropdownElement;
        new (): HTMLMfpDropdownElement;
    };
    interface HTMLMfpEmptyStateElement extends Components.MfpEmptyState, HTMLStencilElement {
    }
    var HTMLMfpEmptyStateElement: {
        prototype: HTMLMfpEmptyStateElement;
        new (): HTMLMfpEmptyStateElement;
    };
    interface HTMLMfpIconElementEventMap {
        "svgLoaded": any;
    }
    /**
     * Icons are simplified images that graphically explain the meaning of an object on the screen.
     */
    interface HTMLMfpIconElement extends Components.MfpIcon, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpIconElementEventMap>(type: K, listener: (this: HTMLMfpIconElement, ev: MfpIconCustomEvent<HTMLMfpIconElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpIconElementEventMap>(type: K, listener: (this: HTMLMfpIconElement, ev: MfpIconCustomEvent<HTMLMfpIconElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpIconElement: {
        prototype: HTMLMfpIconElement;
        new (): HTMLMfpIconElement;
    };
    interface HTMLMfpInputElementEventMap {
        "mfpBlur": HTMLMfpInputElement;
        "mfpChange": { value: string | number | string[]; el: HTMLMfpInputElement };
        "mfpClear": HTMLMfpInputElement;
        "mfpFocus": HTMLMfpInputElement;
        "mfpInput": { value: string | number | string[]; el: HTMLMfpInputElement };
    }
    interface HTMLMfpInputElement extends Components.MfpInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpInputElementEventMap>(type: K, listener: (this: HTMLMfpInputElement, ev: MfpInputCustomEvent<HTMLMfpInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpInputElementEventMap>(type: K, listener: (this: HTMLMfpInputElement, ev: MfpInputCustomEvent<HTMLMfpInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpInputElement: {
        prototype: HTMLMfpInputElement;
        new (): HTMLMfpInputElement;
    };
    interface HTMLMfpNotificationElementEventMap {
        "mfpHide": any;
        "mfpShow": any;
        "mfpAfterOpen": any;
        "mfpAfterClose": any;
    }
    interface HTMLMfpNotificationElement extends Components.MfpNotification, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpNotificationElementEventMap>(type: K, listener: (this: HTMLMfpNotificationElement, ev: MfpNotificationCustomEvent<HTMLMfpNotificationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpNotificationElementEventMap>(type: K, listener: (this: HTMLMfpNotificationElement, ev: MfpNotificationCustomEvent<HTMLMfpNotificationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpNotificationElement: {
        prototype: HTMLMfpNotificationElement;
        new (): HTMLMfpNotificationElement;
    };
    interface HTMLMfpOptionElementEventMap {
        "mfpBlur": HTMLMfpOptionElement;
        "mfpFocus": HTMLMfpOptionElement;
        "mfpClick": HTMLMfpOptionElement;
        "mfpEnter": HTMLMfpOptionElement;
    }
    interface HTMLMfpOptionElement extends Components.MfpOption, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpOptionElementEventMap>(type: K, listener: (this: HTMLMfpOptionElement, ev: MfpOptionCustomEvent<HTMLMfpOptionElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpOptionElementEventMap>(type: K, listener: (this: HTMLMfpOptionElement, ev: MfpOptionCustomEvent<HTMLMfpOptionElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpOptionElement: {
        prototype: HTMLMfpOptionElement;
        new (): HTMLMfpOptionElement;
    };
    interface HTMLMfpOptionGroupElement extends Components.MfpOptionGroup, HTMLStencilElement {
    }
    var HTMLMfpOptionGroupElement: {
        prototype: HTMLMfpOptionGroupElement;
        new (): HTMLMfpOptionGroupElement;
    };
    interface HTMLMfpOptionListElementEventMap {
        "mfpSelect": { value: string; item: HTMLMfpOptionElement };
    }
    interface HTMLMfpOptionListElement extends Components.MfpOptionList, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpOptionListElementEventMap>(type: K, listener: (this: HTMLMfpOptionListElement, ev: MfpOptionListCustomEvent<HTMLMfpOptionListElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpOptionListElementEventMap>(type: K, listener: (this: HTMLMfpOptionListElement, ev: MfpOptionListCustomEvent<HTMLMfpOptionListElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpOptionListElement: {
        prototype: HTMLMfpOptionListElement;
        new (): HTMLMfpOptionListElement;
    };
    interface HTMLMfpPageTitleElement extends Components.MfpPageTitle, HTMLStencilElement {
    }
    var HTMLMfpPageTitleElement: {
        prototype: HTMLMfpPageTitleElement;
        new (): HTMLMfpPageTitleElement;
    };
    interface HTMLMfpPanelElement extends Components.MfpPanel, HTMLStencilElement {
    }
    var HTMLMfpPanelElement: {
        prototype: HTMLMfpPanelElement;
        new (): HTMLMfpPanelElement;
    };
    interface HTMLMfpProgressElement extends Components.MfpProgress, HTMLStencilElement {
    }
    var HTMLMfpProgressElement: {
        prototype: HTMLMfpProgressElement;
        new (): HTMLMfpProgressElement;
    };
    interface HTMLMfpRadioElementEventMap {
        "mfpClick": HTMLMfpRadioElement;
        "mfpFocus": HTMLMfpRadioElement;
        "mfpBlur": HTMLMfpRadioElement;
        "mfpKeyDown": KeyboardEvent;
    }
    interface HTMLMfpRadioElement extends Components.MfpRadio, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpRadioElementEventMap>(type: K, listener: (this: HTMLMfpRadioElement, ev: MfpRadioCustomEvent<HTMLMfpRadioElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpRadioElementEventMap>(type: K, listener: (this: HTMLMfpRadioElement, ev: MfpRadioCustomEvent<HTMLMfpRadioElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpRadioElement: {
        prototype: HTMLMfpRadioElement;
        new (): HTMLMfpRadioElement;
    };
    interface HTMLMfpRadioGroupElementEventMap {
        "mfpChange": { value: string; target: HTMLMfpRadioElement };
    }
    interface HTMLMfpRadioGroupElement extends Components.MfpRadioGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpRadioGroupElementEventMap>(type: K, listener: (this: HTMLMfpRadioGroupElement, ev: MfpRadioGroupCustomEvent<HTMLMfpRadioGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpRadioGroupElementEventMap>(type: K, listener: (this: HTMLMfpRadioGroupElement, ev: MfpRadioGroupCustomEvent<HTMLMfpRadioGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpRadioGroupElement: {
        prototype: HTMLMfpRadioGroupElement;
        new (): HTMLMfpRadioGroupElement;
    };
    interface HTMLMfpSelectElementEventMap {
        "mfpBlur": HTMLMfpSelectElement;
        "mfpClear": HTMLMfpSelectElement;
        "mfpFocus": HTMLMfpSelectElement;
        "mfpSelect": { value: string | number | string[]; item: HTMLMfpOptionElement };
    }
    interface HTMLMfpSelectElement extends Components.MfpSelect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpSelectElementEventMap>(type: K, listener: (this: HTMLMfpSelectElement, ev: MfpSelectCustomEvent<HTMLMfpSelectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpSelectElementEventMap>(type: K, listener: (this: HTMLMfpSelectElement, ev: MfpSelectCustomEvent<HTMLMfpSelectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpSelectElement: {
        prototype: HTMLMfpSelectElement;
        new (): HTMLMfpSelectElement;
    };
    interface HTMLMfpSideMenuElementEventMap {
        "mfpCollapse": { collapse: boolean };
        "mfpSelect": HTMLMfpSideMenuItemElement;
    }
    interface HTMLMfpSideMenuElement extends Components.MfpSideMenu, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpSideMenuElementEventMap>(type: K, listener: (this: HTMLMfpSideMenuElement, ev: MfpSideMenuCustomEvent<HTMLMfpSideMenuElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpSideMenuElementEventMap>(type: K, listener: (this: HTMLMfpSideMenuElement, ev: MfpSideMenuCustomEvent<HTMLMfpSideMenuElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpSideMenuElement: {
        prototype: HTMLMfpSideMenuElement;
        new (): HTMLMfpSideMenuElement;
    };
    interface HTMLMfpSideMenuItemElementEventMap {
        "mfpBlur": HTMLMfpSideMenuItemElement;
        "mfpFocus": HTMLMfpSideMenuItemElement;
        "mfpClick": HTMLMfpSideMenuItemElement;
    }
    interface HTMLMfpSideMenuItemElement extends Components.MfpSideMenuItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpSideMenuItemElementEventMap>(type: K, listener: (this: HTMLMfpSideMenuItemElement, ev: MfpSideMenuItemCustomEvent<HTMLMfpSideMenuItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpSideMenuItemElementEventMap>(type: K, listener: (this: HTMLMfpSideMenuItemElement, ev: MfpSideMenuItemCustomEvent<HTMLMfpSideMenuItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpSideMenuItemElement: {
        prototype: HTMLMfpSideMenuItemElement;
        new (): HTMLMfpSideMenuItemElement;
    };
    interface HTMLMfpSliderElementEventMap {
        "mfpChange": { value: Exclude<TSliderValue, string>; el: HTMLMfpSliderElement };
        "mfpBlur": HTMLMfpSliderElement;
        "mfpFocus": HTMLMfpSliderElement;
    }
    interface HTMLMfpSliderElement extends Components.MfpSlider, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpSliderElementEventMap>(type: K, listener: (this: HTMLMfpSliderElement, ev: MfpSliderCustomEvent<HTMLMfpSliderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpSliderElementEventMap>(type: K, listener: (this: HTMLMfpSliderElement, ev: MfpSliderCustomEvent<HTMLMfpSliderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpSliderElement: {
        prototype: HTMLMfpSliderElement;
        new (): HTMLMfpSliderElement;
    };
    /**
     * Spinners are designed for users to display data loading.
     */
    interface HTMLMfpSpinnerElement extends Components.MfpSpinner, HTMLStencilElement {
    }
    var HTMLMfpSpinnerElement: {
        prototype: HTMLMfpSpinnerElement;
        new (): HTMLMfpSpinnerElement;
    };
    interface HTMLMfpStatusElement extends Components.MfpStatus, HTMLStencilElement {
    }
    var HTMLMfpStatusElement: {
        prototype: HTMLMfpStatusElement;
        new (): HTMLMfpStatusElement;
    };
    interface HTMLMfpStepItemElementEventMap {
        "mfpClick": { target: HTMLMfpStepItemElement; value: string };
    }
    interface HTMLMfpStepItemElement extends Components.MfpStepItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpStepItemElementEventMap>(type: K, listener: (this: HTMLMfpStepItemElement, ev: MfpStepItemCustomEvent<HTMLMfpStepItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpStepItemElementEventMap>(type: K, listener: (this: HTMLMfpStepItemElement, ev: MfpStepItemCustomEvent<HTMLMfpStepItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpStepItemElement: {
        prototype: HTMLMfpStepItemElement;
        new (): HTMLMfpStepItemElement;
    };
    interface HTMLMfpStepsElement extends Components.MfpSteps, HTMLStencilElement {
    }
    var HTMLMfpStepsElement: {
        prototype: HTMLMfpStepsElement;
        new (): HTMLMfpStepsElement;
    };
    interface HTMLMfpSwitchElementEventMap {
        "mfpChange": { checked: boolean };
        "mfpFocus": HTMLMfpSwitchElement;
        "mfpBlur": HTMLMfpSwitchElement;
    }
    /**
     * Toggle switches are digital on/off switches.
     * They should provide immediate results, giving users the freedom to control their preferences as needed.
     */
    interface HTMLMfpSwitchElement extends Components.MfpSwitch, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpSwitchElementEventMap>(type: K, listener: (this: HTMLMfpSwitchElement, ev: MfpSwitchCustomEvent<HTMLMfpSwitchElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpSwitchElementEventMap>(type: K, listener: (this: HTMLMfpSwitchElement, ev: MfpSwitchCustomEvent<HTMLMfpSwitchElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpSwitchElement: {
        prototype: HTMLMfpSwitchElement;
        new (): HTMLMfpSwitchElement;
    };
    interface HTMLMfpTabElementEventMap {
        "mfpClick": HTMLMfpTabElement;
        "mfpFocus": HTMLMfpTabElement;
        "mfpBlur": HTMLMfpTabElement;
        "mfpKeyDown": KeyboardEvent;
    }
    interface HTMLMfpTabElement extends Components.MfpTab, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpTabElementEventMap>(type: K, listener: (this: HTMLMfpTabElement, ev: MfpTabCustomEvent<HTMLMfpTabElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpTabElementEventMap>(type: K, listener: (this: HTMLMfpTabElement, ev: MfpTabCustomEvent<HTMLMfpTabElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpTabElement: {
        prototype: HTMLMfpTabElement;
        new (): HTMLMfpTabElement;
    };
    interface HTMLMfpTabGroupElementEventMap {
        "mfpChange": { target: HTMLMfpTabElement; value: string };
    }
    interface HTMLMfpTabGroupElement extends Components.MfpTabGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpTabGroupElementEventMap>(type: K, listener: (this: HTMLMfpTabGroupElement, ev: MfpTabGroupCustomEvent<HTMLMfpTabGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpTabGroupElementEventMap>(type: K, listener: (this: HTMLMfpTabGroupElement, ev: MfpTabGroupCustomEvent<HTMLMfpTabGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpTabGroupElement: {
        prototype: HTMLMfpTabGroupElement;
        new (): HTMLMfpTabGroupElement;
    };
    interface HTMLMfpTagElementEventMap {
        "mfpClose": any;
        "mfpOpen": any;
        "mfpBlur": HTMLMfpTagElement;
        "mfpClick": HTMLMfpTagElement;
        "mfpFocus": HTMLMfpTagElement;
    }
    interface HTMLMfpTagElement extends Components.MfpTag, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpTagElementEventMap>(type: K, listener: (this: HTMLMfpTagElement, ev: MfpTagCustomEvent<HTMLMfpTagElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpTagElementEventMap>(type: K, listener: (this: HTMLMfpTagElement, ev: MfpTagCustomEvent<HTMLMfpTagElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpTagElement: {
        prototype: HTMLMfpTagElement;
        new (): HTMLMfpTagElement;
    };
    interface HTMLMfpTextareaElementEventMap {
        "mfpBlur": HTMLMfpTextareaElement;
        "mfpChange": { value: string; el: HTMLMfpTextareaElement };
        "mfpClear": HTMLMfpTextareaElement;
        "mfpFocus": HTMLMfpTextareaElement;
        "mfpInput": { value: string; el: HTMLMfpTextareaElement };
    }
    interface HTMLMfpTextareaElement extends Components.MfpTextarea, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpTextareaElementEventMap>(type: K, listener: (this: HTMLMfpTextareaElement, ev: MfpTextareaCustomEvent<HTMLMfpTextareaElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpTextareaElementEventMap>(type: K, listener: (this: HTMLMfpTextareaElement, ev: MfpTextareaCustomEvent<HTMLMfpTextareaElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpTextareaElement: {
        prototype: HTMLMfpTextareaElement;
        new (): HTMLMfpTextareaElement;
    };
    interface HTMLMfpToastElementEventMap {
        "mfpHide": HTMLMfpToastElement;
        "mfpShow": HTMLMfpToastElement;
    }
    interface HTMLMfpToastElement extends Components.MfpToast, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMfpToastElementEventMap>(type: K, listener: (this: HTMLMfpToastElement, ev: MfpToastCustomEvent<HTMLMfpToastElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMfpToastElementEventMap>(type: K, listener: (this: HTMLMfpToastElement, ev: MfpToastCustomEvent<HTMLMfpToastElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMfpToastElement: {
        prototype: HTMLMfpToastElement;
        new (): HTMLMfpToastElement;
    };
    interface HTMLMfpTooltipElement extends Components.MfpTooltip, HTMLStencilElement {
    }
    var HTMLMfpTooltipElement: {
        prototype: HTMLMfpTooltipElement;
        new (): HTMLMfpTooltipElement;
    };
    interface HTMLElementTagNameMap {
        "mfp-accordion": HTMLMfpAccordionElement;
        "mfp-accordion-group": HTMLMfpAccordionGroupElement;
        "mfp-alert": HTMLMfpAlertElement;
        "mfp-avatar": HTMLMfpAvatarElement;
        "mfp-badge": HTMLMfpBadgeElement;
        "mfp-breadcrumb": HTMLMfpBreadcrumbElement;
        "mfp-breadcrumb-item": HTMLMfpBreadcrumbItemElement;
        "mfp-button": HTMLMfpButtonElement;
        "mfp-card": HTMLMfpCardElement;
        "mfp-checkbox": HTMLMfpCheckboxElement;
        "mfp-date-picker": HTMLMfpDatePickerElement;
        "mfp-dialog": HTMLMfpDialogElement;
        "mfp-divider": HTMLMfpDividerElement;
        "mfp-drawer": HTMLMfpDrawerElement;
        "mfp-dropdown": HTMLMfpDropdownElement;
        "mfp-empty-state": HTMLMfpEmptyStateElement;
        "mfp-icon": HTMLMfpIconElement;
        "mfp-input": HTMLMfpInputElement;
        "mfp-notification": HTMLMfpNotificationElement;
        "mfp-option": HTMLMfpOptionElement;
        "mfp-option-group": HTMLMfpOptionGroupElement;
        "mfp-option-list": HTMLMfpOptionListElement;
        "mfp-page-title": HTMLMfpPageTitleElement;
        "mfp-panel": HTMLMfpPanelElement;
        "mfp-progress": HTMLMfpProgressElement;
        "mfp-radio": HTMLMfpRadioElement;
        "mfp-radio-group": HTMLMfpRadioGroupElement;
        "mfp-select": HTMLMfpSelectElement;
        "mfp-side-menu": HTMLMfpSideMenuElement;
        "mfp-side-menu-item": HTMLMfpSideMenuItemElement;
        "mfp-slider": HTMLMfpSliderElement;
        "mfp-spinner": HTMLMfpSpinnerElement;
        "mfp-status": HTMLMfpStatusElement;
        "mfp-step-item": HTMLMfpStepItemElement;
        "mfp-steps": HTMLMfpStepsElement;
        "mfp-switch": HTMLMfpSwitchElement;
        "mfp-tab": HTMLMfpTabElement;
        "mfp-tab-group": HTMLMfpTabGroupElement;
        "mfp-tag": HTMLMfpTagElement;
        "mfp-textarea": HTMLMfpTextareaElement;
        "mfp-toast": HTMLMfpToastElement;
        "mfp-tooltip": HTMLMfpTooltipElement;
    }
}
declare namespace LocalJSX {
    interface MfpAccordion {
        /**
          * The appearance style of accordion
         */
        "appearance"?: TAccordionAppearance;
        /**
          * If true accordion is disabled
         */
        "disabled"?: boolean;
        /**
          * If true accordion is expanded
         */
        "expanded"?: boolean;
        /**
          * Animation is set through JS when the browser does not support CSS calc-size() If true, the accordion animation, will be disabled. No animation will be applied.
         */
        "noAnimation"?: boolean;
        /**
          * Handler to be called after the accordion is closed
         */
        "onMfpAfterClose"?: (event: MfpAccordionCustomEvent<HTMLMfpAccordionElement>) => void;
        /**
          * Handler to be called after the accordion is opened
         */
        "onMfpAfterOpen"?: (event: MfpAccordionCustomEvent<HTMLMfpAccordionElement>) => void;
        /**
          * Handler to be called when the accordion loses focus
         */
        "onMfpBlur"?: (event: MfpAccordionCustomEvent<HTMLMfpAccordionElement>) => void;
        "onMfpClick"?: (event: MfpAccordionCustomEvent<HTMLMfpAccordionElement>) => void;
        /**
          * Handler to be called when the accordion is closed
         */
        "onMfpClose"?: (event: MfpAccordionCustomEvent<HTMLMfpAccordionElement>) => void;
        /**
          * Handler to be called when the accordion gets focus
         */
        "onMfpFocus"?: (event: MfpAccordionCustomEvent<HTMLMfpAccordionElement>) => void;
        /**
          * Handler to be called when the accordion is opened
         */
        "onMfpOpen"?: (event: MfpAccordionCustomEvent<HTMLMfpAccordionElement>) => void;
        /**
          * If true accordion expand icon is rotate 180deg when expanded
         */
        "rotate"?: boolean;
        /**
          * The size of accordion
         */
        "size"?: TAccordionSize;
    }
    interface MfpAccordionGroup {
        /**
          * The appearance style of accordion to be applied to all accordions
         */
        "appearance"?: TAccordionAppearance;
        /**
          * If true all accordions are expanded
         */
        "expandAll"?: boolean;
        /**
          * If true multiple accordions can be expanded at the same time
         */
        "multiple"?: boolean;
        /**
          * Animation is set through JS when the browser does not support CSS calc-size() If true, the accordion animation, will be disabled. No animation will be applied.
         */
        "noAnimation"?: boolean;
        /**
          * The size of accordion to be applied to all accordions
         */
        "size"?: TAccordionSize;
    }
    interface MfpAlert {
        /**
          * If true, the alert will automatically hide after the specified amount of time
         */
        "autoDismiss"?: boolean;
        /**
          * The corner radius of the alert component
         */
        "border"?: TAlertBorderRadius;
        /**
          * If true, the close button at the top right of the alert won't be shown
         */
        "disableClose"?: boolean;
        /**
          * If true, the alert icon won't be shown
         */
        "hideIcon"?: boolean;
        /**
          * Callback handler to be called after the alert has been hidden
         */
        "onMfpAfterHide"?: (event: MfpAlertCustomEvent<any>) => void;
        /**
          * Callback handler to be called after the alert has been shown
         */
        "onMfpAfterShow"?: (event: MfpAlertCustomEvent<any>) => void;
        /**
          * Callback handler to be called when the alert is hidden
         */
        "onMfpHide"?: (event: MfpAlertCustomEvent<any>) => void;
        /**
          * Callback handler to be called when the alert is shown
         */
        "onMfpShow"?: (event: MfpAlertCustomEvent<any>) => void;
        /**
          * If true, the alert will be shown
         */
        "open"?: boolean;
        /**
          * If true, the alert component will remain fixed at the top of the page, occupying the full viewport
         */
        "sticky"?: boolean;
        /**
          * The length of time, in milliseconds, after which the alert will close itself. Only valid if `autoDismiss="true"`
         */
        "time"?: number;
        /**
          * Type of Alert
         */
        "type"?: TAlertType;
    }
    interface MfpAvatar {
        /**
          * Alternate text for the avatar image if the image cannot be displayed
         */
        "altText"?: string;
        /**
          * The image source to load on the avatar (this can be also a base64 encoded image)
         */
        "image"?: string;
        /**
          * The text to display on avatar
         */
        "initials"?: string;
        /**
          * A text to use for describing the avatar on assistive devices
         */
        "label"?: string;
        /**
          * The shape of the avatar
         */
        "shape"?: TAvatarShape;
        /**
          * The size of the avatar
         */
        "size"?: TAvatarSize;
    }
    interface MfpBadge {
        /**
          * Badge background color. The value should be a valid value of the palette color
         */
        "backgroundColor"?: string;
        /**
          * The size of the badge. Relevant if badge has no content.
         */
        "size"?: TBadgeSize;
        /**
          * Badge number color. The value should be a valid value of the palette color
         */
        "textColor"?: string;
    }
    interface MfpBreadcrumb {
        /**
          * The `aria-label` attribute to describe the type of navigation
         */
        "ariaLabel"?: string;
        /**
          * Handler to be called when `mfp-breadcrumb-item` item loses focus.
         */
        "onMfpBreadcrumbBlur"?: (event: MfpBreadcrumbCustomEvent<HTMLMfpBreadcrumbItemElement>) => void;
        /**
          * Handler to be called when `mfp-breadcrumb-item` is selected (on click/enter press).
         */
        "onMfpBreadcrumbClick"?: (event: MfpBreadcrumbCustomEvent<HTMLMfpBreadcrumbItemElement>) => void;
        /**
          * Handler to be called when `mfp-breadcrumb-item` item gets focus.
         */
        "onMfpBreadcrumbFocus"?: (event: MfpBreadcrumbCustomEvent<HTMLMfpBreadcrumbItemElement>) => void;
    }
    interface MfpBreadcrumbItem {
        /**
          * The aria-label that corresponds to the full title of the destination page. This won't be shown in the page, but it will be used by screen readers and other assistive devices.
         */
        "ariaLabel"?: string;
        /**
          * If set, the breadcrumb item will be rendered as an `<a>` with this `href`, otherwise, a `<button>` will be rendered.
         */
        "href"?: string;
        /**
          * If true, the item is the last element inside breadcrumb
         */
        "isLastItem"?: boolean;
        /**
          * Handler to be called when item loses focus
         */
        "onMfpBlur"?: (event: MfpBreadcrumbItemCustomEvent<HTMLMfpBreadcrumbItemElement>) => void;
        /**
          * Handler to be called when item is clicked
         */
        "onMfpClick"?: (event: MfpBreadcrumbItemCustomEvent<HTMLMfpBreadcrumbItemElement>) => void;
        /**
          * Handler to be called when item is focused
         */
        "onMfpFocus"?: (event: MfpBreadcrumbItemCustomEvent<HTMLMfpBreadcrumbItemElement>) => void;
        /**
          * Where to display the link in the browser context. Relevant only if `href` is set.
         */
        "rel"?: string;
        /**
          * Where to display the link in the browser context. Relevant only if `href` is set.
         */
        "target"?: '_blank' | '_parent' | '_self' | '_top';
    }
    /**
     * Buttons are designed for users to take action on a page or a screen.
     */
    interface MfpButton {
        /**
          * The appearance style to apply to the button
         */
        "appearance"?: TButtonAppearance;
        /**
          * If `true`, it will make the button fit to its parent width.
         */
        "block"?: boolean;
        /**
          * The corner radius of the button
         */
        "border"?: TButtonBorderRadius;
        /**
          * If true, the button will be disabled (no interaction allowed)
         */
        "disabled"?: boolean;
        /**
          * Tells the browser to treat the linked URL as a download. Only used when `href` is set. Details: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attr-download
         */
        "download"?: string;
        /**
          * When set, the underlying button will be rendered as an `<a>` with this `href` instead of a `<button>`
         */
        "href"?: string;
        /**
          * It determinate how the content should be aligned
         */
        "justifyContent"?: 'left' | 'center' | 'right';
        /**
          * If `true` it will display the button in a loading state
         */
        "loading"?: boolean;
        /**
          * Handler to be called when the button loses focus
         */
        "onMfpBlur"?: (event: MfpButtonCustomEvent<HTMLMfpButtonElement>) => void;
        /**
          * Handler to be called when button gets focus
         */
        "onMfpClick"?: (event: MfpButtonCustomEvent<HTMLMfpButtonElement>) => void;
        /**
          * Handler to be called when the button is clicked
         */
        "onMfpFocus"?: (event: MfpButtonCustomEvent<HTMLMfpButtonElement>) => void;
        /**
          * The size of the button
         */
        "size"?: TButtonSize;
        /**
          * Where to display the linked URL, as the name for a browsing context (a `tab`, `window`, or `<iframe>`) Details: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attr-target
         */
        "target"?: '_blank' | '_parent' | '_self' | '_top';
        /**
          * The default behavior of the button
         */
        "type"?: TButtonType;
        /**
          * The variant of button to apply on top of the appearance (applicable only to `appearance="primary"`)
         */
        "variant"?: TButtonVariant;
    }
    interface MfpCard {
        /**
          * The corner radius of the card component
         */
        "border"?: TCardBorderRadius;
        /**
          * Type of card component
         */
        "type"?: TCardType;
    }
    interface MfpCheckbox {
        /**
          * If true checkbox displays background on hover
         */
        "backgroundOnHover"?: boolean;
        /**
          * If true checkbox is checked
         */
        "checked"?: boolean;
        /**
          * If true checkbox is disabled
         */
        "disabled"?: boolean;
        /**
          * The form ID that the checkbox is associated with
         */
        "formId"?: string;
        /**
          * The native form validation message
         */
        "formValidationMessage"?: string;
        /**
          * A state that is neither checked nor unchecked
         */
        "indeterminate"?: boolean;
        /**
          * Name of the HTML input form control. Submitted with the form as part of a name/value pair.
         */
        "name": string;
        /**
          * Handler to be called when the checkbox loses focus
         */
        "onMfpBlur"?: (event: MfpCheckboxCustomEvent<HTMLMfpCheckboxElement>) => void;
        /**
          * Handler to be called when the checkbox state changes
         */
        "onMfpChange"?: (event: MfpCheckboxCustomEvent<{ checked: boolean }>) => void;
        /**
          * Handler to be called when the checkbox gets focus
         */
        "onMfpFocus"?: (event: MfpCheckboxCustomEvent<HTMLMfpCheckboxElement>) => void;
        /**
          * If `true`, it will indicate that the user must specify a value for the checkbox before the owning form can be submitted
         */
        "required"?: boolean;
        /**
          * A string representing the value of the checkbox. Primarily used to differentiate a list of related checkboxes that have the same name.
         */
        "value": string;
    }
    interface MfpDatePicker {
        /**
          * If `true`, the Date picker input will be focused on component render
         */
        "autofocus"?: boolean;
        /**
          * The clear button aria label
         */
        "clearButtonLabel"?: string;
        /**
          * If `true`, the clear button won't be displayed
         */
        "disableClear"?: boolean;
        /**
          * Indicates whether the Date picker input is disabled or not. If `true`, the Date picker is disabled and cannot be interacted with.
         */
        "disabled"?: boolean;
        /**
          * Represents the distance (gutter or margin) between the Date picker panel and the input element.
         */
        "distance"?: number;
        /**
          * The first day of the week, where Sunday is 0, Monday is 1, etc
         */
        "firstDayOfWeek"?: DaysOfWeek;
        /**
          * The ID of the form that the Date picker input belongs to.
         */
        "form"?: string;
        /**
          * The options to use when formatting the displayed value. Details: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat#using_options
         */
        "formatOptions"?: Intl.DateTimeFormatOptions;
        /**
          * A function that takes a date and returns true if the date should not be selectable
         */
        "isDateDisallowed"?: (date: Date) => boolean;
        /**
          * The locale for formatting dates. If not set, will use the browser's locale. Details: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#locales_argument
         */
        "locale"?: Intl.LocalesArgument;
        /**
          * The latest date that can be selected
         */
        "max"?: string;
        /**
          * The earliest date that can be selected
         */
        "min"?: string;
        /**
          * Number of months to show when range is `true`
         */
        "months"?: number;
        /**
          * Specifies how the next/previous buttons should navigate the calendar. - single: The buttons will navigate by a single month at a time. - months: The buttons will navigate by the number of months displayed per view.
         */
        "monthsPerView"?: 'single' | 'months';
        /**
          * The Date picker input name.
         */
        "name": string;
        /**
          * Callback handler emitted when the input loses focus
         */
        "onMfpBlur"?: (event: MfpDatePickerCustomEvent<HTMLMfpDatePickerElement>) => void;
        /**
          * Callback handler emitted when the input value has changed and the input loses focus. This handler is called whenever the user finishes typing or pasting text into the input field and then clicks outside of the input field.
         */
        "onMfpChange"?: (event: MfpDatePickerCustomEvent<{ value: string; el: HTMLMfpDatePickerElement }>) => void;
        /**
          * Callback handler emitted when the input value has been cleared
         */
        "onMfpClear"?: (event: MfpDatePickerCustomEvent<HTMLMfpDatePickerElement>) => void;
        /**
          * Callback handler emitted when the input has received focus
         */
        "onMfpFocus"?: (event: MfpDatePickerCustomEvent<HTMLMfpDatePickerElement>) => void;
        /**
          * If `true`, the Date picker panel will be visible.
         */
        "open"?: boolean;
        /**
          * When set, it will override the height of the Date picker panel.
         */
        "panelHeight"?: string;
        /**
          * The Date picker input placeholder text value
         */
        "placeholder"?: string;
        /**
          * Position of the Date picker panel
         */
        "placement"?: Placement;
        /**
          * Indicates whether or not the Date picker input is required to be filled out before submitting the form.
         */
        "required"?: boolean;
        /**
          * Whether to show days outside the month
         */
        "showOutsideDays"?: boolean;
        /**
          * Represents the skidding between the Date picker panel and the input element.
         */
        "skidding"?: number;
        /**
          * Defines the strategy to position the Date picker panel
         */
        "strategy"?: 'fixed' | 'absolute';
        /**
          * The date that is tentatively selected e.g. the start of a range selection
         */
        "tentative"?: string;
        /**
          * It defines how the calendar will behave, allowing single date selection, range selection, or multiple date selection
         */
        "type"?: TDatePickerType;
        /**
          * The validation status of the Select input.
          * @remarks This property is used to indicate the validation status of the select input. It can be set to one of the following values: - `'none'`: No validation status is set. - `'error'`: The input has a validation error. - `'warning'`: The input has a validation warning. - `'success'`: The input has passed validation.
         */
        "validationStatus"?: TInputValidation;
        /**
          * The select input value represents the currently selected date or range and can be used to reset the field to a previous value. All dates are expected in ISO-8601 format (YYYY-MM-DD).
         */
        "value"?: string;
    }
    interface MfpDialog {
        /**
          * Corder radius of the dialog component
         */
        "border"?: TDialogBorderRadius;
        /**
          * If true, the backdrop overlay won't be shown when the dialog opens
         */
        "disableBackdrop"?: boolean;
        /**
          * If true, the dialog will not close when clicking on the backdrop overlay
         */
        "disableCloseClickOutside"?: boolean;
        /**
          * If true, the dialog will not close when the [Esc] key is press
         */
        "disableCloseEscKeydown"?: boolean;
        /**
          * The appearance of footer
         */
        "footerAppearance"?: TDialogFooterAppearance;
        /**
          * If true, it hides the close button
         */
        "hideCloseButton"?: boolean;
        /**
          * Callback handler emitted when the dialog finish closing
         */
        "onMfpAfterClose"?: (event: MfpDialogCustomEvent<void>) => void;
        /**
          * Callback handler emitted when the dialog finish opening
         */
        "onMfpAfterOpen"?: (event: MfpDialogCustomEvent<void>) => void;
        /**
          * Callback handler emitted when the dialog has been canceled or dismissed
         */
        "onMfpCancel"?: (event: MfpDialogCustomEvent<void>) => void;
        /**
          * Callback handler emitted when the dialog will close
         */
        "onMfpClose"?: (event: MfpDialogCustomEvent<void>) => void;
        /**
          * Callback handler emitted when the dialog will open
         */
        "onMfpOpen"?: (event: MfpDialogCustomEvent<void>) => void;
        /**
          * If true, the dialog will be shown as open
         */
        "open"?: boolean;
        /**
          * The size of the dialog
         */
        "size"?: TDialogSize;
    }
    interface MfpDivider {
        /**
          * If true, the divider has a dashed pattern
         */
        "dashed"?: boolean;
        /**
          * The default orientation of the divider
         */
        "orientation"?: TDividerOrientation;
        /**
          * Set the min width of the divider's stroke when text is not centered. Value expressed in px
         */
        "strokeBasis"?: number;
        /**
          * Set the stroke color of the divider. The value should be a valid value of the palette color
         */
        "strokeColor"?: string;
        /**
          * Set the gap of the divider's stroke. This is applicable when the stroke is dashed
         */
        "strokeDashGap"?: number;
        /**
          * Set the width of each dash of the divider's stroke. This is applicable when the stroke is dashed
         */
        "strokeDashWidth"?: number;
        /**
          * Set the line of the divider's stroke. This is applicable when the stroke is dashed
         */
        "strokeLinecap"?: TDividerStrokeLinecap;
        /**
          * Set the thickness of the divider's stroke. Value expressed in px
         */
        "strokeThickness"?: number;
        /**
          * Set the alignment of the title on the main axis of the divider (horizontal / vertical)
         */
        "titleAlignment"?: TDividerTitleAlignment;
    }
    interface MfpDrawer {
        /**
          * If true, the drawer will not close when clicking outside the panel
         */
        "closeOnClickOutside"?: boolean;
        /**
          * If true, the dialog will not close when the [Esc] key is pressed
         */
        "closeOnEsc"?: boolean;
        /**
          * If true, the backdrop overlay will be shown when the drawer opens
         */
        "enableBackdrop"?: boolean;
        /**
          * Callback handler to be called after the drawer has been closed
         */
        "onMfpAfterClose"?: (event: MfpDrawerCustomEvent<any>) => void;
        /**
          * Callback handler to be called after the drawer has been opened
         */
        "onMfpAfterOpen"?: (event: MfpDrawerCustomEvent<any>) => void;
        /**
          * Callback handler to be called when the drawer is closed
         */
        "onMfpClose"?: (event: MfpDrawerCustomEvent<any>) => void;
        /**
          * Callback handler to be called when the drawer is opened
         */
        "onMfpOpen"?: (event: MfpDrawerCustomEvent<any>) => void;
        /**
          * If true, the drawer component will be shown
         */
        "open"?: boolean;
        /**
          * @deprecated Defines the position of the drawer
         */
        "placement"?: TDrawerPlacement;
        /**
          * Defines the position of the drawer
         */
        "position"?: TDrawerPosition;
    }
    interface MfpDropdown {
        /**
          * If true, the dropdown panel will be visible and won't be shown.
         */
        "disabled"?: boolean;
        /**
          * Represents the distance (gutter or margin) between the panel and the trigger element.
         */
        "distance"?: number;
        /**
          * If true, the panel will remain open after a selection is made.
         */
        "keepOpenOnSelect"?: boolean;
        /**
          * Callback handler to be called when the dropdown panel is opened or closed.
         */
        "onMfpOpen"?: (event: MfpDropdownCustomEvent<{ open: boolean }>) => void;
        /**
          * If true, the panel will be visible.
         */
        "open"?: boolean;
        /**
          * When set, it will override the height of the dropdown panel
         */
        "panelHeight"?: string;
        /**
          * Position of the panel
         */
        "placement"?: Placement;
        /**
          * Whether the panel should have the same width as the trigger element
         */
        "sameWidth"?: boolean;
        /**
          * Represents the skidding between the panel and the trigger element.
         */
        "skidding"?: number;
        /**
          * Defines the strategy to position the panel
         */
        "strategy"?: 'fixed' | 'absolute';
    }
    interface MfpEmptyState {
        /**
          * The size of the empty state component
         */
        "size"?: TEmptyStateSize;
    }
    /**
     * Icons are simplified images that graphically explain the meaning of an object on the screen.
     */
    interface MfpIcon {
        /**
          * Set the stroke color of the SVG. The value should be a valid value of the palette color
         */
        "color"?: string;
        /**
          * Label for the icon, used for accessibility
         */
        "label"?: string;
        /**
          * Icon name to load. Please check all available icons [here](https://phosphoricons.com/)
         */
        "name": string;
        /**
          * Callback handler to be called when the SVG has loaded
         */
        "onSvgLoaded"?: (event: MfpIconCustomEvent<any>) => void;
        /**
          * Set the size of the SVG
         */
        "size"?: string | number;
        /**
          * Set the source of the SVG. If the source is set, the name property will be ignored
         */
        "src"?: string;
        /**
          * @deprecated It set the icon weight/style
         */
        "weight"?: TIconWeight;
    }
    interface MfpInput {
        /**
          * Controls whether or not the input field should be capitalized and how. Possible values are 'off', 'none', 'on', 'sentences', 'words', and 'characters'. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/autocapitalize
         */
        "autocapitalize"?: string;
        /**
          * Specifies whether or not the input field should have autocomplete enabled. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete#values
         */
        "autocomplete"?: string;
        /**
          * Controls whether or not the input field should have autocorrect enabled. Possible values are 'on' and 'off'.
         */
        "autocorrect"?: 'on' | 'off';
        /**
          * If true, the input will be focused on component render
         */
        "autofocus"?: boolean;
        /**
          * The clear button aria label
         */
        "clearButtonLabel"?: string;
        /**
          * The amount of time, in milliseconds, to wait before emitting the `mfpInput` event after the input value changes. A value of 0 means no debouncing will occur.
         */
        "debounceTime"?: number;
        /**
          * If true, the clear button won't be displayed
         */
        "disableClear"?: boolean;
        /**
          * Indicates whether the input is disabled or not. If `true`, the input is disabled and cannot be interacted with.
         */
        "disabled"?: boolean;
        /**
          * The ID of the form that the input field belongs to.
         */
        "form"?: string;
        /**
          * The inputmode attribute specifies what kind of input mechanism would be most helpful for users entering content into the input field. This allows a browser to display an appropriate virtual keyboard while editing. Possible values are 'none', 'text', 'decimal', 'numeric', 'tel', 'search', 'email', 'url', and 'date'.
         */
        "inputmode"?: string;
        /**
          * The maximum value that the input field can accept. Only applies to date and number input types.
         */
        "max"?: number | string;
        /**
          * The maximum number of characters that the input field can accept.
         */
        "maxlength"?: number;
        /**
          * The minimum value that the input field can accept. Only applies to date and number input types.
         */
        "min"?: number | string;
        /**
          * The minimum number of characters that the input field can accept.
         */
        "minlength"?: number;
        /**
          * The input field name.
         */
        "name": string;
        /**
          * Callback handler emitted when the input loses focus
         */
        "onMfpBlur"?: (event: MfpInputCustomEvent<HTMLMfpInputElement>) => void;
        /**
          * Callback handler emitted when the input value has changed and the input loses focus. This handler is called whenever the user finishes typing or pasting text into the input field and then clicks outside of the input field.
         */
        "onMfpChange"?: (event: MfpInputCustomEvent<{ value: string | number | string[]; el: HTMLMfpInputElement }>) => void;
        /**
          * Callback handler emitted when the input value has been cleared
         */
        "onMfpClear"?: (event: MfpInputCustomEvent<HTMLMfpInputElement>) => void;
        /**
          * Callback handler emitted when the input has received focus
         */
        "onMfpFocus"?: (event: MfpInputCustomEvent<HTMLMfpInputElement>) => void;
        /**
          * Callback handler emitted when the input value changes. This handler is called whenever the user types or pastes text into the input field.
         */
        "onMfpInput"?: (event: MfpInputCustomEvent<{ value: string | number | string[]; el: HTMLMfpInputElement }>) => void;
        /**
          * Specifies a regular expression the form control's value should match. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/pattern
         */
        "pattern"?: string;
        /**
          * The input placeholder text value
         */
        "placeholder"?: string;
        /**
          * If true, the input field cannot be modified.
         */
        "readonly"?: boolean;
        /**
          * Indicates whether or not the input field is required to be filled out before submitting the form.
         */
        "required"?: boolean;
        /**
          * A number that specifies the granularity that the value must adhere to. Valid for date, month, week, time, datetime-local, number, and range. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#step
         */
        "step"?: number | 'any';
        /**
          * The type attribute specifies the type of input field to display. Possible values are 'text', 'password', 'email', 'number', 'tel', 'search', 'url', and more. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#input_types
         */
        "type"?: TInputType;
        /**
          * The validation status of the input.
          * @remarks This property is used to indicate the validation status of the input. It can be set to one of the following values: - `'none'`: No validation status is set. - `'error'`: The input has a validation error. - `'warning'`: The input has a validation warning. - `'success'`: The input has passed validation.
         */
        "validationStatus"?: TInputValidation;
        /**
          * The input value, it can be used to reset the input to a previous value
         */
        "value"?: TInputValue;
    }
    interface MfpNotification {
        /**
          * If true, the notification will automatically hide after the specified amount of time
         */
        "autoDismiss"?: boolean;
        /**
          * The corder radius of the notification component
         */
        "border"?: TNotificationBorderRadius;
        /**
          * If true, the close button at the top right of the notification won't be shown
         */
        "disableClose"?: boolean;
        /**
          * If true, the notification icon won't be shown
         */
        "hideIcon"?: boolean;
        /**
          * Callback handler to be called after the notification has been closed
         */
        "onMfpAfterClose"?: (event: MfpNotificationCustomEvent<any>) => void;
        /**
          * Callback handler to be called after the notification has been opened
         */
        "onMfpAfterOpen"?: (event: MfpNotificationCustomEvent<any>) => void;
        /**
          * Callback handler to be called when the notification is hidden
         */
        "onMfpHide"?: (event: MfpNotificationCustomEvent<any>) => void;
        /**
          * Callback handler to be called when the notification is shown
         */
        "onMfpShow"?: (event: MfpNotificationCustomEvent<any>) => void;
        /**
          * If true, the notification will be shown
         */
        "open"?: boolean;
        /**
          * The length of time, in milliseconds, after which the notification will close itself. Only valid if `autoDismiss="true"`
         */
        "time"?: number;
        /**
          * Type of Notification
         */
        "type"?: TNotificationType;
    }
    interface MfpOption {
        /**
          * If true, the option is disabled.
         */
        "disabled"?: boolean;
        /**
          * If true, the option is hidden.
         */
        "hidden"?: boolean;
        /**
          * Handler to be called when item loses focus
         */
        "onMfpBlur"?: (event: MfpOptionCustomEvent<HTMLMfpOptionElement>) => void;
        /**
          * Handler to be called when item is clicked
         */
        "onMfpClick"?: (event: MfpOptionCustomEvent<HTMLMfpOptionElement>) => void;
        /**
          * Handler to be called on enter key press
         */
        "onMfpEnter"?: (event: MfpOptionCustomEvent<HTMLMfpOptionElement>) => void;
        /**
          * Handler to be called when item is focused
         */
        "onMfpFocus"?: (event: MfpOptionCustomEvent<HTMLMfpOptionElement>) => void;
        /**
          * If true, the option is selected and active.
         */
        "selected"?: boolean;
        /**
          * A string representing the value of the option. Can be used to identify the item
         */
        "value"?: string;
    }
    interface MfpOptionGroup {
    }
    interface MfpOptionList {
        /**
          * Aria label for the list.
         */
        "ariaLabel"?: string;
        /**
          * Handler to be called when `mfp-option` is selected (on click/enter press).
         */
        "onMfpSelect"?: (event: MfpOptionListCustomEvent<{ value: string; item: HTMLMfpOptionElement }>) => void;
    }
    interface MfpPageTitle {
    }
    interface MfpPanel {
        /**
          * Represents the distance (gutter or margin) between the panel and the trigger element.
         */
        "distance"?: number;
        /**
          * If true, the panel will be visible.
         */
        "open"?: boolean;
        /**
          * Position of the panel
         */
        "placement"?: Placement;
        /**
          * Whether the panel should have the same width as the trigger element
         */
        "sameWidth"?: boolean;
        /**
          * Represents the skidding between the panel and the trigger element.
         */
        "skidding"?: number;
        /**
          * Defines the strategy to position the panel
         */
        "strategy"?: 'fixed' | 'absolute';
    }
    interface MfpProgress {
        /**
          * It will set the border style of the progress bar
         */
        "borderShape"?: TProgressBorderShape;
        /**
          * If `true`, a tooltip will be shown displaying the progress value
         */
        "enableTooltip"?: boolean;
        /**
          * If `true` the indeterminate state of progress bar is enabled
         */
        "indeterminate"?: boolean;
        /**
          * If `true`, a label text showing the value (in percentage) will be shown
         */
        "label"?: boolean;
        /**
          * Progress bar thickness
         */
        "thickness"?: TProgressThickness;
        /**
          * Progress type
         */
        "type"?: TProgressType;
        /**
          * A number representing the current value of the progress bar
         */
        "value"?: number;
    }
    interface MfpRadio {
        /**
          * If true radio displays background on hover
         */
        "backgroundOnHover"?: boolean;
        /**
          * If true radio input is checked
         */
        "checked"?: boolean;
        /**
          * If true radio input is disabled
         */
        "disabled"?: boolean;
        /**
          * The form ID that the radio input is associated with
         */
        "formId"?: string;
        /**
          * Name of the HTML input form control. Submitted with the form as part of a name/value pair.
         */
        "name": string;
        /**
          * Handler to be called when the radio loses focus
         */
        "onMfpBlur"?: (event: MfpRadioCustomEvent<HTMLMfpRadioElement>) => void;
        /**
          * Handler to be called when the radio state changes
         */
        "onMfpClick"?: (event: MfpRadioCustomEvent<HTMLMfpRadioElement>) => void;
        /**
          * Handler to be called when the radio gets focus
         */
        "onMfpFocus"?: (event: MfpRadioCustomEvent<HTMLMfpRadioElement>) => void;
        /**
          * Handler to be called when the radio key is pressed
         */
        "onMfpKeyDown"?: (event: MfpRadioCustomEvent<KeyboardEvent>) => void;
        /**
          * If `true`, it will indicate that the user must specify a value for the radio before the owning form can be submitted
         */
        "required"?: boolean;
        /**
          * A string representing the value of the radio.
         */
        "value": string;
    }
    interface MfpRadioGroup {
        /**
          * If true, all radio inputs in the group will display a background on hover
         */
        "backgroundOnHover"?: boolean;
        /**
          * A number representing the delay time (in milliseconds) that `mfpChange` event handler gets triggered once the value change
         */
        "debounceTime"?: number;
        /**
          * If true radio inputs are disabled
         */
        "disabled"?: boolean;
        /**
          * If true displays fieldset
         */
        "fieldset"?: boolean;
        /**
          * Name of the HTML input form control. Submitted with the form as part of a name/value pair.
         */
        "name": string;
        /**
          * Handler to be called when the radio state changes
         */
        "onMfpChange"?: (event: MfpRadioGroupCustomEvent<{ value: string; target: HTMLMfpRadioElement }>) => void;
        /**
          * The display orientation of the radio inputs
         */
        "orientation"?: TRadioGroupOrientation;
        /**
          * A string representing the value of the radio.
         */
        "value"?: string;
    }
    interface MfpSelect {
        /**
          * If true, the Select input will be focused on component render
         */
        "autofocus"?: boolean;
        /**
          * The clear button aria label
         */
        "clearButtonLabel"?: string;
        /**
          * The amount of time, in milliseconds, to wait before emitting the `mfpInput` event after the input value changes. A value of 0 means no debouncing will occur.
         */
        "debounceTime"?: number;
        /**
          * If true, the clear button won't be displayed
         */
        "disableClear"?: boolean;
        /**
          * Indicates whether the Select input is disabled or not. If `true`, the Select is disabled and cannot be interacted with.
         */
        "disabled"?: boolean;
        /**
          * Represents the distance (gutter or margin) between the Select panel and the input element.
         */
        "distance"?: number;
        /**
          * The ID of the form that the Select input belongs to.
         */
        "form"?: string;
        /**
          * If true, the Select panel will remain open after a selection is made.
         */
        "keepOpenOnSelect"?: boolean;
        /**
          * The maximum number of tags to display when multiple selection is enabled
         */
        "maxTagsVisible"?: number;
        /**
          * If true, the Select input will allow multiple selections.
         */
        "multiple"?: boolean;
        /**
          * The Select input name.
         */
        "name": string;
        /**
          * Callback handler emitted when the Select input loses focus
         */
        "onMfpBlur"?: (event: MfpSelectCustomEvent<HTMLMfpSelectElement>) => void;
        /**
          * Callback handler emitted when the selected value has been cleared
         */
        "onMfpClear"?: (event: MfpSelectCustomEvent<HTMLMfpSelectElement>) => void;
        /**
          * Callback handler emitted when the Select input has received focus
         */
        "onMfpFocus"?: (event: MfpSelectCustomEvent<HTMLMfpSelectElement>) => void;
        /**
          * Callback handler emitted when the selected value has changed
         */
        "onMfpSelect"?: (event: MfpSelectCustomEvent<{ value: string | number | string[]; item: HTMLMfpOptionElement }>) => void;
        /**
          * If true, the Select panel will be visible.
         */
        "open"?: boolean;
        /**
          * When set, it will override the height of the Select panel.
         */
        "panelHeight"?: string;
        /**
          * The Select input placeholder text value
         */
        "placeholder"?: string;
        /**
          * Position of the Select panel
         */
        "placement"?: Placement;
        /**
          * If true, the list of options cannot be filtered (searching won't be available)
         */
        "readonly"?: boolean;
        /**
          * Indicates whether or not the Select input is required to be filled out before submitting the form.
         */
        "required"?: boolean;
        /**
          * Whether the panel should have the Select same width as the input element
         */
        "sameWidth"?: boolean;
        /**
          * Represents the skidding between the Select panel and the input element.
         */
        "skidding"?: number;
        /**
          * Defines the strategy to position the Select panel
         */
        "strategy"?: 'fixed' | 'absolute';
        /**
          * The validation status of the Select input.
          * @remarks This property is used to indicate the validation status of the select input. It can be set to one of the following values: - `'none'`: No validation status is set. - `'error'`: The input has a validation error. - `'warning'`: The input has a validation warning. - `'success'`: The input has passed validation.
         */
        "validationStatus"?: TInputValidation;
        /**
          * The select input value, it can be used to reset the field to a previous value
         */
        "value"?: TSelectValue;
    }
    interface MfpSideMenu {
        /**
          * It sets a predefined appearance of the side menu
         */
        "appearance"?: TSideMenuAppearance;
        /**
          * If true, the container will reduce its width
         */
        "collapse"?: boolean;
        /**
          * Callback handler to be called when the Side menu changes its width from expanded to collapse and vice versa
         */
        "onMfpCollapse"?: (event: MfpSideMenuCustomEvent<{ collapse: boolean }>) => void;
        /**
          * Callback handler to be called when the active/selected menu item changes
         */
        "onMfpSelect"?: (event: MfpSideMenuCustomEvent<HTMLMfpSideMenuItemElement>) => void;
        /**
          * It sets the size of the navigation menu items
         */
        "size"?: TSideMenuSize;
    }
    interface MfpSideMenuItem {
        /**
          * If true, the menu item will be shown as active/selected.
         */
        "active"?: boolean;
        /**
          * If true, the item label and suffix will be hidden and the with will be reduce according to its parent
         */
        "collapse"?: boolean;
        /**
          * If true, the menu item will be disabled (no interaction allowed)
         */
        "disabled"?: boolean;
        /**
          * Handler to be called when the button loses focus
         */
        "onMfpBlur"?: (event: MfpSideMenuItemCustomEvent<HTMLMfpSideMenuItemElement>) => void;
        /**
          * Handler to be called when button gets focus
         */
        "onMfpClick"?: (event: MfpSideMenuItemCustomEvent<HTMLMfpSideMenuItemElement>) => void;
        /**
          * Handler to be called when the button is clicked
         */
        "onMfpFocus"?: (event: MfpSideMenuItemCustomEvent<HTMLMfpSideMenuItemElement>) => void;
    }
    interface MfpSlider {
        /**
          * The amount of time, in milliseconds, to wait to trigger the `mfpChange` event after each value change.
         */
        "debounceTime"?: number;
        /**
          * If `true` the slider is disabled.
         */
        "disabled"?: boolean;
        /**
          * If `true`, a tooltip will be shown displaying the progress value
         */
        "enableTooltip"?: boolean;
        /**
          * If `true` it will show the value label on a side of the slider track area
         */
        "enableValueIndicator"?: boolean;
        /**
          * A number representing the amount to remain between the minimum and maximum values (only for range type).
         */
        "gap"?: number;
        /**
          * A number representing the max value of the slider.
         */
        "max"?: number;
        /**
          * A number representing the min value of the slider.
         */
        "min"?: number;
        /**
          * Handler to be called when the slider loses focus
         */
        "onMfpBlur"?: (event: MfpSliderCustomEvent<HTMLMfpSliderElement>) => void;
        /**
          * Handler to be called when change the value on range inputs
         */
        "onMfpChange"?: (event: MfpSliderCustomEvent<{ value: Exclude<TSliderValue, string>; el: HTMLMfpSliderElement }>) => void;
        /**
          * Handler to be called when the slider gets focused
         */
        "onMfpFocus"?: (event: MfpSliderCustomEvent<HTMLMfpSliderElement>) => void;
        /**
          * A number representing the step of the slider. ⚠️ Please notice that the value (or list of values if the slider type is `range`) will be rounded to the nearest multiple of `step`.
         */
        "step"?: number;
        /**
          * If `true`, a tooltip will always display the progress value. It relies on enableTooltip and if enableTooltip is false, tooltipAlwaysVisible cannot be true.
         */
        "tooltipAlwaysVisible"?: boolean;
        /**
          * It defines the type of slider to display
         */
        "type"?: TSliderType;
        /**
          * The value of the slider. - If the slider type is `single`, the value is a number. - If the slider type is `range`, the value is an array of two numbers (the first number represents the `min` value and the second number represents the `max` value).
         */
        "value"?: TSliderValue;
    }
    /**
     * Spinners are designed for users to display data loading.
     */
    interface MfpSpinner {
        /**
          * If `false`, the animation on the icon element will be stopped
         */
        "animation"?: boolean;
        /**
          * It defines the size of the icon element displayed
         */
        "size"?: TSpinnerSize;
        /**
          * It defines the position of the label text
         */
        "textPosition"?: TSpinnerTextPosition;
    }
    interface MfpStatus {
        /**
          * It defines the type of status to display
         */
        "type"?: TStatusType;
    }
    interface MfpStepItem {
        /**
          * Callback handler emitted when the step item is clicked
         */
        "onMfpClick"?: (event: MfpStepItemCustomEvent<{ target: HTMLMfpStepItemElement; value: string }>) => void;
        /**
          * It defines prefix size
         */
        "size"?: TStepsSize;
        /**
          * It defines step item appearance based on its status
         */
        "status"?: TStepItemStatus;
        /**
          * It defines the step item type used
         */
        "type"?: TStepsType;
    }
    interface MfpSteps {
        /**
          * The color of the line that connects the steps. It should be a valid declarative color token.
         */
        "dividerColor"?: string;
        /**
          * The size of the steps
         */
        "size"?: TStepsSize;
        /**
          * The type of prefix element to use on the step items
         */
        "type"?: TStepsType;
    }
    /**
     * Toggle switches are digital on/off switches.
     * They should provide immediate results, giving users the freedom to control their preferences as needed.
     */
    interface MfpSwitch {
        /**
          * If true, a background will be displayed on hover
         */
        "backgroundOnHover"?: boolean;
        /**
          * It indicates whether if the switch is `ON` by default (when the page loads)
         */
        "checked"?: boolean;
        /**
          * If true, the switch control will be disabled and no interaction will be allowed
         */
        "disabled"?: boolean;
        /**
          * If true, the component will take the full width space available on the parent container
         */
        "fullWidth"?: boolean;
        /**
          * It indicates how to to display the on/off marks inside the control, with icons or none (default)
         */
        "innerLabel"?: TSwitchInnerLabel;
        /**
          * It defines how to distribute the space between and around the control and the label text (https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content)
         */
        "justifyContent"?: TSwitchJustifyContent;
        /**
          * Name of the form control. Submitted with the form as part of a name/value pair
         */
        "name": string;
        /**
          * Handler to be called when the switch loses focus
         */
        "onMfpBlur"?: (event: MfpSwitchCustomEvent<HTMLMfpSwitchElement>) => void;
        /**
          * Handler to be called when the switch state changes
         */
        "onMfpChange"?: (event: MfpSwitchCustomEvent<{ checked: boolean }>) => void;
        /**
          * Handler to be called when the switch gets focus
         */
        "onMfpFocus"?: (event: MfpSwitchCustomEvent<HTMLMfpSwitchElement>) => void;
        /**
          * If `true`, it will indicate that the user must switch `ON` the element before the owning form can be submitted
         */
        "required"?: boolean;
        /**
          * If true, the order of the control and the label text will be changed
         */
        "reverseOrder"?: boolean;
        /**
          * The input control's value, submitted as a name/value pair with form data.
         */
        "value"?: string;
    }
    interface MfpTab {
        /**
          * If true tab is active
         */
        "active"?: boolean;
        /**
          * The tab panel id that the tab controls
         */
        "controls": string;
        /**
          * If true tab is disabled
         */
        "disabled"?: boolean;
        /**
          * Handler to be called when the tab loses focus
         */
        "onMfpBlur"?: (event: MfpTabCustomEvent<HTMLMfpTabElement>) => void;
        /**
          * Handler to be called when the tab state changes
         */
        "onMfpClick"?: (event: MfpTabCustomEvent<HTMLMfpTabElement>) => void;
        /**
          * Handler to be called when the tab gets focus
         */
        "onMfpFocus"?: (event: MfpTabCustomEvent<HTMLMfpTabElement>) => void;
        /**
          * Handler to be called when the tab key is pressed
         */
        "onMfpKeyDown"?: (event: MfpTabCustomEvent<KeyboardEvent>) => void;
        /**
          * The direction that tab should be render
         */
        "orientation"?: TTabOrientation;
        /**
          * The placement that tab should be render
         */
        "placement"?: TTabPlacement;
        /**
          * The size of the tab
         */
        "size"?: TTabSize;
        /**
          * The id of the tab
         */
        "tabId": string;
    }
    interface MfpTabGroup {
        /**
          * A number representing the delay value applied to mfpChange event handler
         */
        "debounceTime"?: number;
        /**
          * If true, the underline divider below the tabs won't be shown
         */
        "disableDivider"?: boolean;
        /**
          * Handler to be called when the tab value changes
         */
        "onMfpChange"?: (event: MfpTabGroupCustomEvent<{ target: HTMLMfpTabElement; value: string }>) => void;
        /**
          * The direction that tab should be render
         */
        "orientation"?: TTabOrientation;
        /**
          * The placement that tab should be render
         */
        "placement"?: TTabPlacement;
        /**
          * The size of the tab
         */
        "size"?: TTabSize;
        /**
          * A string representing the id of the selected tab.
         */
        "value"?: string;
    }
    interface MfpTag {
        /**
          * The corner radius of the Tag (will override size's predefined border)
         */
        "border"?: TTagBorderRadius;
        /**
          * If true, the Tag can be clickable
         */
        "clickable"?: boolean;
        /**
          * The color style of the Tag
         */
        "color"?: TTagColor;
        /**
          * If true, the Tag will be disabled (only if clickable = `true`, no interaction allowed)
         */
        "disabled"?: boolean;
        /**
          * If true, the Tag component will hidden (only if removable = `true`)
         */
        "hidden"?: boolean;
        /**
          * Handler to be called when tag loses focus
         */
        "onMfpBlur"?: (event: MfpTagCustomEvent<HTMLMfpTagElement>) => void;
        /**
          * Handler to be called when tag is clicked
         */
        "onMfpClick"?: (event: MfpTagCustomEvent<HTMLMfpTagElement>) => void;
        /**
          * Callback handler to be called when the tag is close/hidden
         */
        "onMfpClose"?: (event: MfpTagCustomEvent<any>) => void;
        /**
          * Handler to be called when tag is focused
         */
        "onMfpFocus"?: (event: MfpTagCustomEvent<HTMLMfpTagElement>) => void;
        /**
          * Callback handler to be called when the tag is not open/shown
         */
        "onMfpOpen"?: (event: MfpTagCustomEvent<any>) => void;
        /**
          * If true, the Tag component can be removed
         */
        "removable"?: boolean;
        /**
          * If true, the Tag is selected (only if clickable = `true`)
         */
        "selected"?: boolean;
        /**
          * The size of the Tag component
         */
        "size"?: TTagSize;
        /**
          * The variant of Tag to apply on top of the variant
         */
        "variant"?: TTagVariant;
    }
    interface MfpTextarea {
        /**
          * If `true`, the textarea will automatically grow and shrink to fit its contents. If `false`, the textarea will have a fixed height specified by the `rows` property.
         */
        "autoGrow"?: boolean;
        /**
          * Controls whether or not the textarea field should be capitalized and how. Possible values are 'off', 'none', 'on', 'sentences', 'words', and 'characters'. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/autocapitalize
         */
        "autocapitalize"?: TTextareaAutoCapitalize;
        /**
          * Specifies whether or not the textarea field should have autocomplete enabled. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete#values
         */
        "autocomplete"?: string;
        /**
          * Controls whether or not the textarea field should have autocorrect enabled. Possible values are 'on' and 'off'.
         */
        "autocorrect"?: 'on' | 'off';
        /**
          * If true, the textarea will be focused on component render
         */
        "autofocus"?: boolean;
        /**
          * The amount of time, in milliseconds, to wait before emitting the `mfpInput` event after the textarea value changes. A value of 0 means no debouncing will occur.
         */
        "debounceTime"?: number;
        /**
          * If `true`, it will block the user's ability to resize the textarea.
         */
        "disableResize"?: boolean;
        /**
          * If `true`, the user cannot interact with the textarea.
         */
        "disabled"?: boolean;
        /**
          * The ID of the form that the textarea field belongs to.
         */
        "form"?: string;
        /**
          * The maximum number of characters that can be entered into the textarea (`0`: no limit). When enabled, a character counter will be shown underneath the textarea.
         */
        "maxlength"?: number;
        /**
          * The name of the textarea element.
         */
        "name": string;
        /**
          * Callback handler emitted when the textarea loses focus
         */
        "onMfpBlur"?: (event: MfpTextareaCustomEvent<HTMLMfpTextareaElement>) => void;
        /**
          * Callback handler emitted when the textarea value has changed and the textarea loses focus. This handler is called whenever the user finishes typing or pasting text into the textarea field and then clicks outside of the textarea field.
         */
        "onMfpChange"?: (event: MfpTextareaCustomEvent<{ value: string; el: HTMLMfpTextareaElement }>) => void;
        /**
          * Callback handler emitted when the textarea value has been cleared
         */
        "onMfpClear"?: (event: MfpTextareaCustomEvent<HTMLMfpTextareaElement>) => void;
        /**
          * Callback handler emitted when the textarea has received focus
         */
        "onMfpFocus"?: (event: MfpTextareaCustomEvent<HTMLMfpTextareaElement>) => void;
        /**
          * Callback handler emitted when the textarea value changes. This handler is called whenever the user types or pastes text into the textarea field.
         */
        "onMfpInput"?: (event: MfpTextareaCustomEvent<{ value: string; el: HTMLMfpTextareaElement }>) => void;
        /**
          * The placeholder text to show when there is no value.
         */
        "placeholder": string;
        /**
          * If true, the textarea field cannot be modified.
         */
        "readonly"?: boolean;
        /**
          * Indicates whether or not the textarea field is required to be filled out before submitting the form.
         */
        "required"?: boolean;
        /**
          * The number of visible text lines for the control. It must be a positive integer.
         */
        "rows"?: number;
        /**
          * If true, the textarea content may be checked for spelling errors.
         */
        "spellcheck"?: boolean;
        /**
          * The validation status of the textarea.
          * @remarks This property is used to indicate the validation status of the textarea. It can be set to one of the following values: - `'none'`: No validation status is set. - `'error'`: The textarea has a validation error. - `'warning'`: The textarea has a validation warning. - `'success'`: The textarea has passed validation.
         */
        "validationStatus"?: TInputValidation;
        /**
          * The value of the textarea. It can be used to reset the textarea to a previous value.
         */
        "value"?: string;
        /**
          * Specifies how the text in a text area is to be wrapped when submitted in a form
         */
        "wrap"?: TTextareaWrap;
    }
    interface MfpToast {
        /**
          * The corder radius of the toast component
         */
        "border"?: TToastBorderRadius;
        /**
          * If true will hide toast icon
         */
        "hideIcon"?: boolean;
        /**
          * Callback handler to be called when the notification is hidden
         */
        "onMfpHide"?: (event: MfpToastCustomEvent<HTMLMfpToastElement>) => void;
        /**
          * Callback handler to be called when the notification is shown
         */
        "onMfpShow"?: (event: MfpToastCustomEvent<HTMLMfpToastElement>) => void;
        /**
          * If true, the toast will be shown
         */
        "open"?: boolean;
        /**
          * Placement of toast
         */
        "placement"?: TToastPlacement;
        /**
          * The length of time, in milliseconds, after which the toast will close itself
         */
        "time"?: number;
        /**
          * Type of toast
         */
        "type"?: TToastType;
    }
    interface MfpTooltip {
        /**
          * If true, the tooltip will always be visible
         */
        "alwaysVisible"?: boolean;
        /**
          * Set the action when the tooltip should be displayed, on hover (default) or click
         */
        "displayOn"?: 'click' | 'hover';
        /**
          * Distance between trigger element and tooltip
         */
        "distance"?: number;
        /**
          * If true, the arrow on the tooltip content won't be shown
         */
        "hideArrow"?: boolean;
        "placement"?: Placement;
        /**
          * Whether the tooltip should have the same width as the trigger element (applicable only for content shorter than the trigger element)
         */
        "sameWidth"?: boolean;
        /**
          * Indicates whether or not the tooltip is visible when the component is first rendered, and when interacting with the trigger
         */
        "visible"?: boolean;
    }
    interface IntrinsicElements {
        "mfp-accordion": MfpAccordion;
        "mfp-accordion-group": MfpAccordionGroup;
        "mfp-alert": MfpAlert;
        "mfp-avatar": MfpAvatar;
        "mfp-badge": MfpBadge;
        "mfp-breadcrumb": MfpBreadcrumb;
        "mfp-breadcrumb-item": MfpBreadcrumbItem;
        "mfp-button": MfpButton;
        "mfp-card": MfpCard;
        "mfp-checkbox": MfpCheckbox;
        "mfp-date-picker": MfpDatePicker;
        "mfp-dialog": MfpDialog;
        "mfp-divider": MfpDivider;
        "mfp-drawer": MfpDrawer;
        "mfp-dropdown": MfpDropdown;
        "mfp-empty-state": MfpEmptyState;
        "mfp-icon": MfpIcon;
        "mfp-input": MfpInput;
        "mfp-notification": MfpNotification;
        "mfp-option": MfpOption;
        "mfp-option-group": MfpOptionGroup;
        "mfp-option-list": MfpOptionList;
        "mfp-page-title": MfpPageTitle;
        "mfp-panel": MfpPanel;
        "mfp-progress": MfpProgress;
        "mfp-radio": MfpRadio;
        "mfp-radio-group": MfpRadioGroup;
        "mfp-select": MfpSelect;
        "mfp-side-menu": MfpSideMenu;
        "mfp-side-menu-item": MfpSideMenuItem;
        "mfp-slider": MfpSlider;
        "mfp-spinner": MfpSpinner;
        "mfp-status": MfpStatus;
        "mfp-step-item": MfpStepItem;
        "mfp-steps": MfpSteps;
        "mfp-switch": MfpSwitch;
        "mfp-tab": MfpTab;
        "mfp-tab-group": MfpTabGroup;
        "mfp-tag": MfpTag;
        "mfp-textarea": MfpTextarea;
        "mfp-toast": MfpToast;
        "mfp-tooltip": MfpTooltip;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "mfp-accordion": LocalJSX.MfpAccordion & JSXBase.HTMLAttributes<HTMLMfpAccordionElement>;
            "mfp-accordion-group": LocalJSX.MfpAccordionGroup & JSXBase.HTMLAttributes<HTMLMfpAccordionGroupElement>;
            "mfp-alert": LocalJSX.MfpAlert & JSXBase.HTMLAttributes<HTMLMfpAlertElement>;
            "mfp-avatar": LocalJSX.MfpAvatar & JSXBase.HTMLAttributes<HTMLMfpAvatarElement>;
            "mfp-badge": LocalJSX.MfpBadge & JSXBase.HTMLAttributes<HTMLMfpBadgeElement>;
            "mfp-breadcrumb": LocalJSX.MfpBreadcrumb & JSXBase.HTMLAttributes<HTMLMfpBreadcrumbElement>;
            "mfp-breadcrumb-item": LocalJSX.MfpBreadcrumbItem & JSXBase.HTMLAttributes<HTMLMfpBreadcrumbItemElement>;
            /**
             * Buttons are designed for users to take action on a page or a screen.
             */
            "mfp-button": LocalJSX.MfpButton & JSXBase.HTMLAttributes<HTMLMfpButtonElement>;
            "mfp-card": LocalJSX.MfpCard & JSXBase.HTMLAttributes<HTMLMfpCardElement>;
            "mfp-checkbox": LocalJSX.MfpCheckbox & JSXBase.HTMLAttributes<HTMLMfpCheckboxElement>;
            "mfp-date-picker": LocalJSX.MfpDatePicker & JSXBase.HTMLAttributes<HTMLMfpDatePickerElement>;
            "mfp-dialog": LocalJSX.MfpDialog & JSXBase.HTMLAttributes<HTMLMfpDialogElement>;
            "mfp-divider": LocalJSX.MfpDivider & JSXBase.HTMLAttributes<HTMLMfpDividerElement>;
            "mfp-drawer": LocalJSX.MfpDrawer & JSXBase.HTMLAttributes<HTMLMfpDrawerElement>;
            "mfp-dropdown": LocalJSX.MfpDropdown & JSXBase.HTMLAttributes<HTMLMfpDropdownElement>;
            "mfp-empty-state": LocalJSX.MfpEmptyState & JSXBase.HTMLAttributes<HTMLMfpEmptyStateElement>;
            /**
             * Icons are simplified images that graphically explain the meaning of an object on the screen.
             */
            "mfp-icon": LocalJSX.MfpIcon & JSXBase.HTMLAttributes<HTMLMfpIconElement>;
            "mfp-input": LocalJSX.MfpInput & JSXBase.HTMLAttributes<HTMLMfpInputElement>;
            "mfp-notification": LocalJSX.MfpNotification & JSXBase.HTMLAttributes<HTMLMfpNotificationElement>;
            "mfp-option": LocalJSX.MfpOption & JSXBase.HTMLAttributes<HTMLMfpOptionElement>;
            "mfp-option-group": LocalJSX.MfpOptionGroup & JSXBase.HTMLAttributes<HTMLMfpOptionGroupElement>;
            "mfp-option-list": LocalJSX.MfpOptionList & JSXBase.HTMLAttributes<HTMLMfpOptionListElement>;
            "mfp-page-title": LocalJSX.MfpPageTitle & JSXBase.HTMLAttributes<HTMLMfpPageTitleElement>;
            "mfp-panel": LocalJSX.MfpPanel & JSXBase.HTMLAttributes<HTMLMfpPanelElement>;
            "mfp-progress": LocalJSX.MfpProgress & JSXBase.HTMLAttributes<HTMLMfpProgressElement>;
            "mfp-radio": LocalJSX.MfpRadio & JSXBase.HTMLAttributes<HTMLMfpRadioElement>;
            "mfp-radio-group": LocalJSX.MfpRadioGroup & JSXBase.HTMLAttributes<HTMLMfpRadioGroupElement>;
            "mfp-select": LocalJSX.MfpSelect & JSXBase.HTMLAttributes<HTMLMfpSelectElement>;
            "mfp-side-menu": LocalJSX.MfpSideMenu & JSXBase.HTMLAttributes<HTMLMfpSideMenuElement>;
            "mfp-side-menu-item": LocalJSX.MfpSideMenuItem & JSXBase.HTMLAttributes<HTMLMfpSideMenuItemElement>;
            "mfp-slider": LocalJSX.MfpSlider & JSXBase.HTMLAttributes<HTMLMfpSliderElement>;
            /**
             * Spinners are designed for users to display data loading.
             */
            "mfp-spinner": LocalJSX.MfpSpinner & JSXBase.HTMLAttributes<HTMLMfpSpinnerElement>;
            "mfp-status": LocalJSX.MfpStatus & JSXBase.HTMLAttributes<HTMLMfpStatusElement>;
            "mfp-step-item": LocalJSX.MfpStepItem & JSXBase.HTMLAttributes<HTMLMfpStepItemElement>;
            "mfp-steps": LocalJSX.MfpSteps & JSXBase.HTMLAttributes<HTMLMfpStepsElement>;
            /**
             * Toggle switches are digital on/off switches.
             * They should provide immediate results, giving users the freedom to control their preferences as needed.
             */
            "mfp-switch": LocalJSX.MfpSwitch & JSXBase.HTMLAttributes<HTMLMfpSwitchElement>;
            "mfp-tab": LocalJSX.MfpTab & JSXBase.HTMLAttributes<HTMLMfpTabElement>;
            "mfp-tab-group": LocalJSX.MfpTabGroup & JSXBase.HTMLAttributes<HTMLMfpTabGroupElement>;
            "mfp-tag": LocalJSX.MfpTag & JSXBase.HTMLAttributes<HTMLMfpTagElement>;
            "mfp-textarea": LocalJSX.MfpTextarea & JSXBase.HTMLAttributes<HTMLMfpTextareaElement>;
            "mfp-toast": LocalJSX.MfpToast & JSXBase.HTMLAttributes<HTMLMfpToastElement>;
            "mfp-tooltip": LocalJSX.MfpTooltip & JSXBase.HTMLAttributes<HTMLMfpTooltipElement>;
        }
    }
}
